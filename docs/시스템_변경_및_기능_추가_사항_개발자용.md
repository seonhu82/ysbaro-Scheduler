# ì—°ì„¸ë°”ë¡œì¹˜ê³¼ ì‹œìŠ¤í…œ ë³€ê²½ ë° ê¸°ëŠ¥ ì¶”ê°€ ì‚¬í•­ (ê°œë°œììš©)

**ì‘ì„±ì¼**: 2025ë…„ 10ì›” 22ì¼  
**ì¶œì²˜**: Dental clinic proposal file update ëŒ€í™” ë¶„ì„  
**ëª©ì **: ì‹œìŠ¤í…œ ë³€ê²½ ë° ì‹ ê·œ ê¸°ëŠ¥ êµ¬í˜„ì„ ìœ„í•œ ê°œë°œ ê°€ì´ë“œ

---

## ğŸ“‹ ëª©ì°¨

1. [ê·¼ë¬´ ì‹œìŠ¤í…œ ë³€ê²½](#1-ê·¼ë¬´-ì‹œìŠ¤í…œ-ë³€ê²½)
2. [ì›ì¥ íŒ¨í„´ ê´€ë¦¬ í™•ì¥](#2-ì›ì¥-íŒ¨í„´-ê´€ë¦¬-í™•ì¥)
3. [ë°°ì¹˜ ì‹œìŠ¤í…œ ê°œì„ ](#3-ë°°ì¹˜-ì‹œìŠ¤í…œ-ê°œì„ )
4. [ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ ì‹œìŠ¤í…œ ë³´ì•ˆ ê°•í™”](#4-ì˜¤í”„ì—°ì°¨-ì‹ ì²­-ì‹œìŠ¤í…œ-ë³´ì•ˆ-ê°•í™”)
5. [UI/UX ê°œì„  ì‚¬í•­](#5-uiux-ê°œì„ -ì‚¬í•­)
6. [ì£¼ì°¨ ê¸°ì¤€ ë¡œì§ ë³€ê²½](#6-ì£¼ì°¨-ê¸°ì¤€-ë¡œì§-ë³€ê²½)
7. [í†µê³„ ë° í˜„í™© í‘œì‹œ ë°©ì‹](#7-í†µê³„-ë°-í˜„í™©-í‘œì‹œ-ë°©ì‹)
8. [ì¹´ì¹´ì˜¤í†¡ ì—°ë™ ê´€ë ¨](#8-ì¹´ì¹´ì˜¤í†¡-ì—°ë™-ê´€ë ¨)

---

## 1. ê·¼ë¬´ ì‹œìŠ¤í…œ ë³€ê²½

### 1.1 ì£¼4ì¼ ê¸°ë³¸, ê°œë³„ ì„¤ì • ê°€ëŠ¥
**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ì§ì›ë³„ë¡œ ì£¼5ì¼ ë˜ëŠ” ì£¼4ì¼ ê·¼ë¬´ ì„ íƒ
- ë³€ê²½: **ê¸°ë³¸ê°’ ì£¼4ì¼, í•„ìš”ì‹œ ì§ì›ë³„ë¡œ ì£¼5ì¼ ì„¤ì • ê°€ëŠ¥**

**ì˜í–¥ ë²”ìœ„**:
- ì§ì› ê´€ë¦¬ í…Œì´ë¸”: `work_type` í•„ë“œ ìœ ì§€, ê¸°ë³¸ê°’ 'ì£¼4ì¼'
- ì˜¤í”„ ê³„ì‚° ë¡œì§: ê·¼ë¬´ í˜•íƒœì— ë”°ë¼ ìë™ ê³„ì‚°
- UI: ì£¼4ì¼ ê¸°ë³¸ ì„ íƒ, í•„ìš”ì‹œ ì£¼5ì¼ ë³€ê²½ ê°€ëŠ¥

**êµ¬í˜„ ì½”ë“œ ì˜ˆì‹œ**:
```python
# ì§ì› ëª¨ë¸
class Employee:
    work_type = models.CharField(
        max_length=10,
        choices=[('ì£¼5ì¼', 'ì£¼5ì¼'), ('ì£¼4ì¼', 'ì£¼4ì¼')],
        default='ì£¼4ì¼',  # ê¸°ë³¸ê°’ ì£¼4ì¼
        help_text='ê·¼ë¬´ í˜•íƒœ'
    )
    
    def get_weekly_off_days(self):
        """ì£¼ê°„ ì˜¤í”„ ì¼ìˆ˜ ë°˜í™˜"""
        return 1 if self.work_type == 'ì£¼5ì¼' else 2
    
    def get_monthly_off_days(self):
        """ì›”ê°„ ì˜¤í”„ ì¼ìˆ˜ ë°˜í™˜"""
        return 4 if self.work_type == 'ì£¼5ì¼' else 8
    
    def get_annual_leave_days(self):
        """ì—°ì°¨ ì¼ìˆ˜ ë°˜í™˜ (ì£¼5ì¼ë§Œ í•´ë‹¹)"""
        if self.work_type == 'ì£¼5ì¼':
            # ê·¼ì† ì—°ìˆ˜ì— ë”°ë¼ ê³„ì‚°
            years = self.get_years_of_service()
            if years < 1:
                return 15
            elif years < 3:
                return 15
            else:
                return min(15 + ((years - 1) // 2), 25)
        else:
            return 0  # ì£¼4ì¼ì€ ì—°ì°¨ ì—†ìŒ
```

**ì§ì› ë“±ë¡/ìˆ˜ì • UI**:
```python
class EmployeeForm:
    """ì§ì› ë“±ë¡/ìˆ˜ì • í¼"""
    
    def render_work_type_field(self):
        """ê·¼ë¬´ í˜•íƒœ í•„ë“œ ë Œë”ë§"""
        return """
        <div class="form-group">
            <label>ê·¼ë¬´ í˜•íƒœ *</label>
            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="work_type" value="ì£¼4ì¼" checked>
                    <span>ì£¼4ì¼ (ê¶Œì¥)</span>
                    <small class="help-text">ì£¼ 2ì¼ ì˜¤í”„, ì›” 8ì¼ ì˜¤í”„</small>
                </label>
                <label class="radio-option">
                    <input type="radio" name="work_type" value="ì£¼5ì¼">
                    <span>ì£¼5ì¼</span>
                    <small class="help-text">ì£¼ 1ì¼ ì˜¤í”„, ì›” 4ì¼ ì˜¤í”„, ì—°ì°¨ 15ì¼</small>
                </label>
            </div>
            <p class="info-text">
                ğŸ’¡ ê¸°ë³¸ê°’ì€ ì£¼4ì¼ì´ë©°, ëŒ€ë¶€ë¶„ì˜ ì§ì›ì—ê²Œ ì ìš©ë©ë‹ˆë‹¤.
            </p>
        </div>
        """
```

### 1.2 ì˜¤í”„ ì¼ìˆ˜ ìë™ ê³„ì‚°
**ë³€ê²½ ë‚´ì—­**:
- ì£¼4ì¼: **ì£¼ 2ì¼ ì˜¤í”„, ì›” 8ì¼ ì˜¤í”„**
- ì£¼5ì¼: **ì£¼ 1ì¼ ì˜¤í”„, ì›” 4ì¼ ì˜¤í”„**

**êµ¬í˜„ ìš”êµ¬ì‚¬í•­**:
```python
# ê²€ì¦ ë¡œì§
def validate_monthly_offs(employee_id, month):
    """ì›”ê°„ ì˜¤í”„ ì¼ìˆ˜ ê²€ì¦"""
    employee = Employee.query.get(employee_id)
    required_offs = employee.get_monthly_off_days()  # ì£¼4ì¼: 8ì¼, ì£¼5ì¼: 4ì¼
    
    actual_offs = count_employee_offs(employee_id, month)
    
    if actual_offs < required_offs:
        return False, f"{required_offs - actual_offs}ì¼ ë¶€ì¡±"
    elif actual_offs > required_offs:
        return False, f"{actual_offs - required_offs}ì¼ ì´ˆê³¼"
    return True, "ì •ìƒ"

def validate_weekly_offs(employee_id, week_start, week_end):
    """ì£¼ê°„ ì˜¤í”„ ì¼ìˆ˜ ê²€ì¦"""
    employee = Employee.query.get(employee_id)
    required_offs = employee.get_weekly_off_days()  # ì£¼4ì¼: 2ì¼, ì£¼5ì¼: 1ì¼
    
    actual_offs = count_employee_offs(employee_id, week_start, week_end)
    
    if actual_offs != required_offs:
        return False, f"ì£¼ {required_offs}ì¼ í•„ìš” (í˜„ì¬: {actual_offs}ì¼)"
    return True, "ì •ìƒ"
```

### 1.3 ì—°ì°¨ ì‹œìŠ¤í…œ (ì£¼5ì¼ë§Œ ì ìš©)
**ë³€ê²½ ë‚´ì—­**:
- ì£¼5ì¼ ê·¼ë¬´ì: ì—°ì°¨ ì‹œìŠ¤í…œ ìœ ì§€
- ì£¼4ì¼ ê·¼ë¬´ì: ì—°ì°¨ ì—†ìŒ (ì˜¤í”„ë§Œ ì‚¬ìš©)

**ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°**:
```sql
-- íœ´ê°€ ê¸°ë¡ í…Œì´ë¸”
CREATE TABLE leave_records (
    id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    leave_date DATE NOT NULL,
    leave_type VARCHAR(10) NOT NULL,  -- 'ì˜¤í”„', 'ì—°ì°¨'
    status VARCHAR(10) DEFAULT 'approved',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    INDEX idx_employee_date (employee_id, leave_date),
    INDEX idx_leave_type (leave_type)
);

-- ì—°ì°¨ ì œì•½: ì£¼5ì¼ ì§ì›ë§Œ 'ì—°ì°¨' ì‚¬ìš© ê°€ëŠ¥
-- ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ ê²€ì¦
```

**ì—°ì°¨ ì‹ ì²­ ê²€ì¦**:
```python
class LeaveApplicationValidator:
    """íœ´ê°€ ì‹ ì²­ ê²€ì¦"""
    
    def validate_leave_type(self, employee_id, leave_type):
        """íœ´ê°€ ìœ í˜• ê²€ì¦"""
        employee = Employee.query.get(employee_id)
        
        if leave_type == 'ì—°ì°¨':
            if employee.work_type != 'ì£¼5ì¼':
                return {
                    'valid': False,
                    'message': 'ì£¼4ì¼ ê·¼ë¬´ìëŠ” ì—°ì°¨ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¤í”„ë¥¼ ì‹ ì²­í•´ì£¼ì„¸ìš”.'
                }
            
            # ì”ì—¬ ì—°ì°¨ í™•ì¸
            remaining_annual = self.get_remaining_annual_leave(employee_id)
            if remaining_annual <= 0:
                return {
                    'valid': False,
                    'message': 'ì”ì—¬ ì—°ì°¨ê°€ ì—†ìŠµë‹ˆë‹¤.'
                }
        
        elif leave_type == 'ì˜¤í”„':
            # ì˜¤í”„ëŠ” ëª¨ë“  ì§ì› ì‚¬ìš© ê°€ëŠ¥
            pass
        
        return {'valid': True, 'message': 'ê²€ì¦ ì„±ê³µ'}
    
    def get_remaining_annual_leave(self, employee_id):
        """ì”ì—¬ ì—°ì°¨ ì¼ìˆ˜ ì¡°íšŒ"""
        employee = Employee.query.get(employee_id)
        
        if employee.work_type != 'ì£¼5ì¼':
            return 0
        
        # ì˜¬í•´ ë¶€ì—¬ëœ ì—°ì°¨
        total_annual = employee.get_annual_leave_days()
        
        # ì˜¬í•´ ì‚¬ìš©í•œ ì—°ì°¨
        current_year = datetime.now().year
        used_annual = LeaveRecord.query.filter(
            LeaveRecord.employee_id == employee_id,
            LeaveRecord.leave_type == 'ì—°ì°¨',
            extract('year', LeaveRecord.leave_date) == current_year
        ).count()
        
        return total_annual - used_annual
```

**UI í‘œì‹œ**:
```python
def render_employee_leave_info(employee):
    """ì§ì›ë³„ íœ´ê°€ ì •ë³´ í‘œì‹œ"""
    info = {
        'name': employee.name,
        'work_type': employee.work_type
    }
    
    if employee.work_type == 'ì£¼5ì¼':
        info['offs'] = {
            'weekly': 1,
            'monthly': 4,
            'current_month_used': count_monthly_offs(employee.id)
        }
        info['annual_leave'] = {
            'total': employee.get_annual_leave_days(),
            'used': count_used_annual_leave(employee.id),
            'remaining': get_remaining_annual_leave(employee.id)
        }
    else:  # ì£¼4ì¼
        info['offs'] = {
            'weekly': 2,
            'monthly': 8,
            'current_month_used': count_monthly_offs(employee.id)
        }
        info['annual_leave'] = None
    
    return info

# HTML í…œí”Œë¦¿
def render_html(employee_info):
    if employee_info['work_type'] == 'ì£¼5ì¼':
        return f"""
        <div class="employee-leave-card">
            <h3>{employee_info['name']} (ì£¼5ì¼ ê·¼ë¬´)</h3>
            <div class="leave-section">
                <h4>ì˜¤í”„</h4>
                <p>ì£¼ 1ì¼, ì›” 4ì¼</p>
                <p>ì´ë²ˆ ë‹¬ ì‚¬ìš©: {employee_info['offs']['current_month_used']}ì¼</p>
            </div>
            <div class="leave-section">
                <h4>ì—°ì°¨</h4>
                <p>ì´ {employee_info['annual_leave']['total']}ì¼</p>
                <p>ì‚¬ìš©: {employee_info['annual_leave']['used']}ì¼</p>
                <p>ì”ì—¬: {employee_info['annual_leave']['remaining']}ì¼</p>
            </div>
        </div>
        """
    else:
        return f"""
        <div class="employee-leave-card">
            <h3>{employee_info['name']} (ì£¼4ì¼ ê·¼ë¬´)</h3>
            <div class="leave-section">
                <h4>ì˜¤í”„</h4>
                <p>ì£¼ 2ì¼, ì›” 8ì¼</p>
                <p>ì´ë²ˆ ë‹¬ ì‚¬ìš©: {employee_info['offs']['current_month_used']}ì¼</p>
            </div>
            <div class="leave-section">
                <p class="info-text">ì—°ì°¨ í•´ë‹¹ ì—†ìŒ</p>
            </div>
        </div>
        """
```

---

## 2. ì›ì¥ íŒ¨í„´ ê´€ë¦¬ í™•ì¥

### 2.1 ì›ì¥ ê·¸ë£¹ ê´€ë¦¬ ë°©ì‹ ë³€ê²½ (Bì•ˆ ì±„íƒ)

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ìš”ì¼ë³„ ê·¸ë£¹ ê´€ë¦¬ë§Œ ê°€ëŠ¥
- ë³€ê²½: **ì „ì²´ ê·¸ë£¹ ë¦¬ìŠ¤íŠ¸ ë°©ì‹ìœ¼ë¡œ í†µí•© ê´€ë¦¬**

**ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°**:
```sql
CREATE TABLE doctor_groups (
    id INT PRIMARY KEY AUTO_INCREMENT,
    group_name VARCHAR(50) NOT NULL,           -- ì˜ˆ: "ì›”-ê·¸ë£¹1"
    day_of_week VARCHAR(10),                   -- "ì›”", "í™”", "ìˆ˜" ë“±
    doctors JSON NOT NULL,                     -- ["ë°•ì°½ë²”", "êµ¬ìœ¤ì§„", "ìœ¤ì•„í–¥"]
    doctor_roles JSON,                         -- {"ë°•ì°½ë²”": "ì§„ë£Œ", "êµ¬ìœ¤ì§„": "ì§„ë£Œ", "ìœ¤ì•„í–¥": "ìƒë‹´"}
    required_staff INT NOT NULL,               -- í•„ìš” ì¸ì›: 14
    has_night_shift BOOLEAN DEFAULT FALSE,     -- ì•¼ê°„ ì§„ë£Œ ì—¬ë¶€
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤ ì¶”ê°€
CREATE INDEX idx_day_of_week ON doctor_groups(day_of_week);
CREATE INDEX idx_is_active ON doctor_groups(is_active);
```

**UI êµ¬í˜„ ìš”êµ¬ì‚¬í•­**:
```python
class DoctorGroupManager:
    """ì›ì¥ ê·¸ë£¹ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def get_groups_by_filter(self, day_filter=None):
        """í•„í„°ë§ëœ ê·¸ë£¹ ëª©ë¡ ì¡°íšŒ
        
        Args:
            day_filter: None(ì „ì²´), "ì›”", "í™”", "ìˆ˜" ë“±
        """
        query = DoctorGroup.query.filter_by(is_active=True)
        
        if day_filter and day_filter != "ì „ì²´":
            query = query.filter_by(day_of_week=day_filter)
        
        return query.order_by(DoctorGroup.day_of_week, DoctorGroup.group_name).all()
    
    def create_group(self, group_data):
        """ìƒˆ ê·¸ë£¹ ìƒì„±
        
        Args:
            group_data = {
                'group_name': 'ì›”-ê·¸ë£¹1',
                'day_of_week': 'ì›”',
                'doctors': ['ë°•ì°½ë²”', 'êµ¬ìœ¤ì§„', 'ìœ¤ì•„í–¥'],
                'doctor_roles': {'ë°•ì°½ë²”': 'ì§„ë£Œ', 'êµ¬ìœ¤ì§„': 'ì§„ë£Œ', 'ìœ¤ì•„í–¥': 'ìƒë‹´'},
                'has_night_shift': False
            }
        """
        # í•„ìš” ì¸ì› ìë™ ê³„ì‚°
        required_staff = self.calculate_required_staff(
            group_data['doctors'],
            group_data['doctor_roles'],
            group_data.get('has_night_shift', False)
        )
        
        new_group = DoctorGroup(
            group_name=group_data['group_name'],
            day_of_week=group_data['day_of_week'],
            doctors=json.dumps(group_data['doctors'], ensure_ascii=False),
            doctor_roles=json.dumps(group_data['doctor_roles'], ensure_ascii=False),
            required_staff=required_staff,
            has_night_shift=group_data.get('has_night_shift', False)
        )
        
        db.session.add(new_group)
        db.session.commit()
        
        return new_group
    
    def calculate_required_staff(self, doctors, doctor_roles, has_night_shift):
        """í•„ìš” ì¸ì› ìë™ ê³„ì‚°
        
        ê·œì¹™:
        - ì§„ë£Œ ì›ì¥ 1ëª…ë‹¹: íŒ€ì¥/ê³ ë…„ì°¨ 1 + ì¤‘ë…„ì°¨ 1 + ì €ë…„ì°¨ 1 = 3ëª…
        - ìƒë‹´ ì›ì¥ 1ëª…ë‹¹: ì¤‘ë…„ì°¨ 1 + ì €ë…„ì°¨ 1 = 2ëª…
        - ì•¼ê°„ ì§„ë£Œ: ì¤‘ë…„ì°¨ +1, ì €ë…„ì°¨ +1 = +2ëª…
        """
        total_staff = 0
        
        for doctor in doctors:
            role = doctor_roles.get(doctor, 'ì§„ë£Œ')
            if role == 'ì§„ë£Œ':
                total_staff += 3
            elif role == 'ìƒë‹´':
                total_staff += 2
        
        if has_night_shift:
            total_staff += 2
        
        return total_staff
```

### 2.2 íŒ¨í„´ ì ìš© ë°©ì‹ í™•ì¥

**ê¸°ëŠ¥ 1: ìš”ì¼ë³„ íŒ¨í„´ (ì „ì²´ ì ìš©)**
```python
class DoctorPatternManager:
    """ì›ì¥ íŒ¨í„´ ê´€ë¦¬"""
    
    def apply_weekly_pattern(self, month, year, pattern_config):
        """ìš”ì¼ë³„ íŒ¨í„´ì„ ì „ì²´ ì›”ì— ì ìš©
        
        Args:
            pattern_config = {
                'ì›”': group_id_1,
                'í™”': group_id_2,
                'ìˆ˜': group_id_3,
                'ëª©': group_id_4,
                'ê¸ˆ': group_id_5,
                'í† ': group_id_6
            }
        """
        days_in_month = calendar.monthrange(year, month)[1]
        
        for day in range(1, days_in_month + 1):
            date_obj = date(year, month, day)
            day_of_week = self.get_korean_day_of_week(date_obj)
            
            # ì¼ìš”ì¼ ë˜ëŠ” ê³µíœ´ì¼ì€ ìŠ¤í‚µ
            if day_of_week == 'ì¼' or self.is_holiday(date_obj):
                continue
            
            group_id = pattern_config.get(day_of_week)
            if group_id:
                self.apply_group_to_date(date_obj, group_id)
        
        return True
    
    def get_korean_day_of_week(self, date_obj):
        """ìš”ì¼ì„ í•œê¸€ë¡œ ë³€í™˜"""
        days = ['ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† ', 'ì¼']
        return days[date_obj.weekday()]
```

**ê¸°ëŠ¥ 2: ì£¼ë³„ íŒ¨í„´ (ì„ íƒ ì ìš©)**
```python
def apply_week_based_pattern(self, month, year, week_pattern_config):
    """ì£¼ë³„ë¡œ ë‹¤ë¥¸ íŒ¨í„´ ì ìš©
    
    Args:
        week_pattern_config = {
            1: pattern_1_config,  # 1ì£¼ì°¨ íŒ¨í„´
            2: pattern_2_config,  # 2ì£¼ì°¨ íŒ¨í„´
            3: pattern_1_config,  # 3ì£¼ì°¨ íŒ¨í„´ (1ì£¼ì°¨ì™€ ë™ì¼)
            4: pattern_2_config,  # 4ì£¼ì°¨ íŒ¨í„´
            5: pattern_2_config   # 5ì£¼ì°¨ íŒ¨í„´
        }
        
        ê° pattern_config = {
            'ì›”': group_id,
            'í™”': group_id,
            ...
        }
    """
    # ì›”ì˜ ì£¼ì°¨ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    weeks = self.get_weeks_in_month(year, month)
    
    for week_num, week_dates in weeks.items():
        pattern_config = week_pattern_config.get(week_num)
        
        if not pattern_config:
            continue
        
        for date_obj in week_dates:
            day_of_week = self.get_korean_day_of_week(date_obj)
            
            # ì¼ìš”ì¼ ë˜ëŠ” ê³µíœ´ì¼ì€ ìŠ¤í‚µ
            if day_of_week == 'ì¼' or self.is_holiday(date_obj):
                continue
            
            group_id = pattern_config.get(day_of_week)
            if group_id:
                self.apply_group_to_date(date_obj, group_id)
    
    return True

def get_weeks_in_month(self, year, month):
    """ì›”ì˜ ì£¼ì°¨ë³„ ë‚ ì§œ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    
    Returns:
        {
            1: [date(2025, 1, 1), date(2025, 1, 2), ...],  # 1ì£¼ì°¨ (ì¼~í† )
            2: [...],  # 2ì£¼ì°¨
            ...
        }
    """
    weeks = {}
    current_week = 1
    current_week_dates = []
    
    days_in_month = calendar.monthrange(year, month)[1]
    
    for day in range(1, days_in_month + 1):
        date_obj = date(year, month, day)
        current_week_dates.append(date_obj)
        
        # í† ìš”ì¼ì´ê±°ë‚˜ ë§ˆì§€ë§‰ ë‚ ì¸ ê²½ìš° ì£¼ì°¨ ì¢…ë£Œ
        if date_obj.weekday() == 5 or day == days_in_month:
            weeks[current_week] = current_week_dates.copy()
            current_week_dates = []
            current_week += 1
    
    return weeks
```

**ê¸°ëŠ¥ 3: ê°œë³„ ë‚ ì§œ ìˆ˜ì •**
```python
def update_date_schedule(self, date_obj, update_type, update_data):
    """íŠ¹ì • ë‚ ì§œì˜ ì›ì¥ ìŠ¤ì¼€ì¤„ ìˆ˜ì •
    
    Args:
        update_type: 'group' ë˜ëŠ” 'custom'
        update_data: 
            - type='group': group_id
            - type='custom': {
                'doctors': ['ë°•ì°½ë²”', 'êµ¬ìœ¤ì§„'],
                'doctor_roles': {'ë°•ì°½ë²”': 'ì§„ë£Œ', 'êµ¬ìœ¤ì§„': 'ìƒë‹´'},
                'has_night_shift': False
              }
    """
    schedule = DailySchedule.query.filter_by(schedule_date=date_obj).first()
    
    if not schedule:
        schedule = DailySchedule(schedule_date=date_obj)
        db.session.add(schedule)
    
    if update_type == 'group':
        # ê·¸ë£¹ ë³€ê²½
        group = DoctorGroup.query.get(update_data)
        schedule.doctor_group_id = group.id
        schedule.required_staff = group.required_staff
        schedule.has_night_shift = group.has_night_shift
        
    elif update_type == 'custom':
        # ì§ì ‘ ìˆ˜ì •
        schedule.doctor_group_id = None  # ê·¸ë£¹ ì—°ê²° í•´ì œ
        schedule.doctors = json.dumps(update_data['doctors'], ensure_ascii=False)
        schedule.doctor_roles = json.dumps(update_data['doctor_roles'], ensure_ascii=False)
        schedule.has_night_shift = update_data.get('has_night_shift', False)
        
        # í•„ìš” ì¸ì› ì¬ê³„ì‚°
        calculator = DoctorPatternManager()
        schedule.required_staff = calculator.calculate_required_staff(
            update_data['doctors'],
            update_data['doctor_roles'],
            schedule.has_night_shift
        )
    
    db.session.commit()
    return schedule
```

---

## 3. ë°°ì¹˜ ì‹œìŠ¤í…œ ê°œì„ 

### 3.1 ë°°ì¹˜ ê¸°ê°„ ì£¼ ë‹¨ìœ„ ì„ íƒ

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ì „ì²´ ì›” í•œ ë²ˆì— ë°°ì¹˜
- ë³€ê²½: **ì£¼ì°¨ë³„ ì„ íƒ ë°°ì¹˜ ê°€ëŠ¥, í™•ì •ëœ ì£¼ì°¨ëŠ” ì„ íƒ ë¶ˆê°€**

**ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°**:
```sql
CREATE TABLE schedule_confirmations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    year INT NOT NULL,
    month INT NOT NULL,
    week_number INT NOT NULL,                  -- 1~5ì£¼ì°¨
    week_start_date DATE NOT NULL,
    week_end_date DATE NOT NULL,
    is_confirmed BOOLEAN DEFAULT FALSE,         -- í™•ì • ì—¬ë¶€
    confirmed_at TIMESTAMP,
    confirmed_by INT,                           -- í™•ì •í•œ ê´€ë¦¬ì ID
    UNIQUE KEY unique_week (year, month, week_number),
    FOREIGN KEY (confirmed_by) REFERENCES users(id)
);
```

**ë°°ì¹˜ ë¡œì§**:
```python
class WeeklyScheduleManager:
    """ì£¼ì°¨ë³„ ìŠ¤ì¼€ì¤„ ê´€ë¦¬"""
    
    def get_available_weeks(self, year, month):
        """ë°°ì¹˜ ê°€ëŠ¥í•œ ì£¼ì°¨ ëª©ë¡ ë°˜í™˜"""
        weeks = self.get_weeks_in_month(year, month)
        confirmations = ScheduleConfirmation.query.filter_by(
            year=year,
            month=month
        ).all()
        
        confirmed_weeks = {conf.week_number for conf in confirmations if conf.is_confirmed}
        
        available_weeks = []
        for week_num, dates in weeks.items():
            available_weeks.append({
                'week_number': week_num,
                'start_date': dates[0],
                'end_date': dates[-1],
                'is_confirmed': week_num in confirmed_weeks,
                'date_range': f"{dates[0].strftime('%m/%d')} ~ {dates[-1].strftime('%m/%d')}"
            })
        
        return available_weeks
    
    def auto_assign_weeks(self, year, month, selected_weeks):
        """ì„ íƒëœ ì£¼ì°¨ë“¤ì— ëŒ€í•´ ìë™ ë°°ì¹˜
        
        Args:
            selected_weeks: [1, 3, 4] í˜•íƒœì˜ ì£¼ì°¨ ë²ˆí˜¸ ë¦¬ìŠ¤íŠ¸
        """
        # í™•ì •ëœ ì£¼ì°¨ í™•ì¸
        confirmed_weeks = self.get_confirmed_weeks(year, month)
        invalid_weeks = set(selected_weeks) & confirmed_weeks
        
        if invalid_weeks:
            raise ValueError(f"í™•ì •ëœ ì£¼ì°¨ëŠ” ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {invalid_weeks}")
        
        # ì„ íƒëœ ì£¼ì°¨ì˜ ë‚ ì§œë“¤ ì¶”ì¶œ
        weeks = self.get_weeks_in_month(year, month)
        target_dates = []
        
        for week_num in selected_weeks:
            if week_num in weeks:
                target_dates.extend(weeks[week_num])
        
        # ìë™ ë°°ì¹˜ ì‹¤í–‰
        result = self.auto_assign_staff(target_dates)
        
        return result
    
    def confirm_week(self, year, month, week_number, user_id):
        """ì£¼ì°¨ í™•ì •"""
        confirmation = ScheduleConfirmation.query.filter_by(
            year=year,
            month=month,
            week_number=week_number
        ).first()
        
        if not confirmation:
            weeks = self.get_weeks_in_month(year, month)
            week_dates = weeks[week_number]
            
            confirmation = ScheduleConfirmation(
                year=year,
                month=month,
                week_number=week_number,
                week_start_date=week_dates[0],
                week_end_date=week_dates[-1]
            )
            db.session.add(confirmation)
        
        confirmation.is_confirmed = True
        confirmation.confirmed_at = datetime.now()
        confirmation.confirmed_by = user_id
        
        db.session.commit()
        
        return confirmation
```

**UI êµ¬í˜„**:
```python
# ì£¼ì°¨ ì„ íƒ UI ë°ì´í„° ìƒì„±
def render_week_selection_ui(year, month):
    """ì£¼ì°¨ ì„ íƒ ì²´í¬ë°•ìŠ¤ UI ë°ì´í„°"""
    manager = WeeklyScheduleManager()
    available_weeks = manager.get_available_weeks(year, month)
    
    ui_data = {
        'title': f'{year}ë…„ {month}ì›” ë°°ì¹˜ ê¸°ê°„ ì„ íƒ',
        'weeks': []
    }
    
    for week_info in available_weeks:
        week_num = week_info['week_number']
        
        # 1ì£¼ì°¨ëŠ” ì´ì „ ì›” í¬í•¨ë  ìˆ˜ ìˆìŒì„ í‘œì‹œ
        label = f"{week_num}ì£¼ì°¨ ({week_info['date_range']})"
        if week_num == 1:
            label += " (ì´ì „ ì›” í¬í•¨ ê°€ëŠ¥)"
        
        ui_data['weeks'].append({
            'value': week_num,
            'label': label,
            'disabled': week_info['is_confirmed'],
            'tooltip': 'í™•ì •ëœ ì£¼ì°¨ì…ë‹ˆë‹¤' if week_info['is_confirmed'] else None
        })
    
    return ui_data
```

### 3.2 ë‚ ì§œ ì…€ ì´ ì¸ì› = 20ëª…

**ë³€ê²½ ë‚´ì—­**:
- ë‚ ì§œë³„ ê°€ìš© ì¸ì› ê³ ì •: **20ëª…**

**ë°ì´í„° êµ¬ì¡°**:
```python
# ìƒìˆ˜ ì •ì˜
TOTAL_STAFF_COUNT = 20

def get_available_staff_count(date_obj):
    """í•´ë‹¹ ë‚ ì§œì˜ ê°€ìš© ì¸ì› ìˆ˜ ê³„ì‚°
    
    Returns:
        {
            'total': 20,
            'assigned': 14,
            'off': 4,
            'annual_leave': 0,
            'absent': 2,
            'available': 0  # ë°°ì¹˜ ê°€ëŠ¥í•œ ë‚¨ì€ ì¸ì›
        }
    """
    # ë°°ì¹˜ëœ ì§ì› ìˆ˜
    assigned = StaffAssignment.query.filter_by(
        assignment_date=date_obj,
        status='assigned'
    ).count()
    
    # ì˜¤í”„ ì§ì› ìˆ˜
    off_count = LeaveRecord.query.filter_by(
        leave_date=date_obj,
        leave_type='ì˜¤í”„'
    ).count()
    
    # ê¸°íƒ€ ë¶€ì¬ (ë³‘ê°€, ê²½ì¡°ì‚¬ ë“±)
    absent = LeaveRecord.query.filter_by(
        leave_date=date_obj,
        leave_type='ê¸°íƒ€'
    ).count()
    
    available = TOTAL_STAFF_COUNT - assigned - off_count - absent
    
    return {
        'total': TOTAL_STAFF_COUNT,
        'assigned': assigned,
        'off': off_count,
        'annual_leave': 0,  # ì—°ì°¨ ì œê±°ë¨
        'absent': absent,
        'available': available
    }
```

---

## 4. ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ ì‹œìŠ¤í…œ ë³´ì•ˆ ê°•í™”

### 4.1 ìƒë…„ì›”ì¼ ì¸ì¦ ì¶”ê°€

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ì´ë¦„ ì„ íƒë§Œìœ¼ë¡œ ì‹ ì²­ (ëŒ€ë¦¬ ì‹ ì²­ ê°€ëŠ¥)
- ë³€ê²½: **ìƒë…„ì›”ì¼ ì¸ì¦ ì¶”ê°€ (6ìë¦¬ ë˜ëŠ” 8ìë¦¬)**

**ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°**:
```sql
-- ì§ì› í…Œì´ë¸”ì— ìƒë…„ì›”ì¼ í•„ë“œ ì¶”ê°€
ALTER TABLE employees 
ADD COLUMN birth_date DATE NOT NULL COMMENT 'ìƒë…„ì›”ì¼ (YYYYMMDD)',
ADD INDEX idx_birth_date (birth_date);

-- ì‹ ì²­ ê¸°ë¡ í…Œì´ë¸”ì— ì¸ì¦ ë¡œê·¸ ì¶”ê°€
CREATE TABLE leave_application_logs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    employee_id INT NOT NULL,
    application_id INT NOT NULL,
    auth_method VARCHAR(20) NOT NULL,          -- 'birth_date'
    auth_input VARCHAR(50),                     -- ì…ë ¥í•œ ìƒë…„ì›”ì¼
    auth_result BOOLEAN NOT NULL,               -- ì¸ì¦ ì„±ê³µ/ì‹¤íŒ¨
    attempt_ip VARCHAR(45),
    attempt_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (employee_id) REFERENCES employees(id),
    FOREIGN KEY (application_id) REFERENCES leave_applications(id)
);
```

**ì¸ì¦ ë¡œì§**:
```python
class LeaveApplicationAuth:
    """ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ ì¸ì¦"""
    
    def authenticate_employee(self, employee_name, birth_date_input):
        """ì§ì› ì¸ì¦
        
        Args:
            employee_name: ì§ì› ì´ë¦„
            birth_date_input: ìƒë…„ì›”ì¼ ì…ë ¥ê°’ (6ìë¦¬ ë˜ëŠ” 8ìë¦¬)
        
        Returns:
            {
                'success': True/False,
                'employee_id': int or None,
                'message': str
            }
        """
        # ì§ì› ì¡°íšŒ
        employee = Employee.query.filter_by(
            name=employee_name,
            is_active=True
        ).first()
        
        if not employee:
            return {
                'success': False,
                'employee_id': None,
                'message': 'ë“±ë¡ë˜ì§€ ì•Šì€ ì§ì›ì…ë‹ˆë‹¤.'
            }
        
        # ìƒë…„ì›”ì¼ í˜•ì‹ ì •ê·œí™”
        normalized_birth_date = self.normalize_birth_date(birth_date_input)
        
        if not normalized_birth_date:
            return {
                'success': False,
                'employee_id': None,
                'message': 'ìƒë…„ì›”ì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (YYMMDD ë˜ëŠ” YYYYMMDD)'
            }
        
        # ìƒë…„ì›”ì¼ ê²€ì¦
        stored_birth_date = employee.birth_date.strftime('%Y%m%d')
        
        if normalized_birth_date == stored_birth_date:
            # ì¸ì¦ ì„±ê³µ ë¡œê·¸
            self.log_auth_attempt(employee.id, True, birth_date_input)
            
            return {
                'success': True,
                'employee_id': employee.id,
                'message': 'ì¸ì¦ ì„±ê³µ'
            }
        else:
            # ì¸ì¦ ì‹¤íŒ¨ ë¡œê·¸
            self.log_auth_attempt(employee.id, False, birth_date_input)
            
            return {
                'success': False,
                'employee_id': None,
                'message': 'ìƒë…„ì›”ì¼ì´ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.'
            }
    
    def normalize_birth_date(self, input_str):
        """ìƒë…„ì›”ì¼ ì…ë ¥ê°’ ì •ê·œí™”
        
        Args:
            input_str: '950315' ë˜ëŠ” '19950315' í˜•íƒœ
        
        Returns:
            'YYYYMMDD' í˜•íƒœ ë˜ëŠ” None
        """
        # ìˆ«ìë§Œ ì¶”ì¶œ
        digits = ''.join(filter(str.isdigit, input_str))
        
        if len(digits) == 6:
            # 6ìë¦¬: YYMMDD
            year = int(digits[:2])
            month = int(digits[2:4])
            day = int(digits[4:6])
            
            # ì—°ë„ ì¶”ì • (00-30 â†’ 2000ë…„ëŒ€, 31-99 â†’ 1900ë…„ëŒ€)
            if year <= 30:
                full_year = 2000 + year
            else:
                full_year = 1900 + year
            
            # ìœ íš¨ì„± ê²€ì‚¬
            try:
                date_obj = date(full_year, month, day)
                return date_obj.strftime('%Y%m%d')
            except ValueError:
                return None
        
        elif len(digits) == 8:
            # 8ìë¦¬: YYYYMMDD
            try:
                year = int(digits[:4])
                month = int(digits[4:6])
                day = int(digits[6:8])
                date_obj = date(year, month, day)
                return date_obj.strftime('%Y%m%d')
            except ValueError:
                return None
        
        else:
            return None
    
    def log_auth_attempt(self, employee_id, success, input_value):
        """ì¸ì¦ ì‹œë„ ë¡œê·¸ ê¸°ë¡"""
        log_entry = LeaveApplicationLog(
            employee_id=employee_id,
            auth_method='birth_date',
            auth_input=input_value,
            auth_result=success,
            attempt_ip=request.remote_addr if request else None
        )
        db.session.add(log_entry)
        db.session.commit()
```

**í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„**:
```javascript
// ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ í¼
class LeaveApplicationForm {
    constructor() {
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        document.getElementById('submit-btn').addEventListener('click', 
            () => this.handleSubmit());
    }
    
    async handleSubmit() {
        const employeeName = document.getElementById('employee-select').value;
        const birthDate = document.getElementById('birth-date-input').value;
        const selectedDates = this.getSelectedDates();
        
        // ì…ë ¥ê°’ ê²€ì¦
        if (!employeeName) {
            alert('ì´ë¦„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
            return;
        }
        
        if (!birthDate) {
            alert('ìƒë…„ì›”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        if (selectedDates.length === 0) {
            alert('ë‚ ì§œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
            return;
        }
        
        // ìƒë…„ì›”ì¼ í˜•ì‹ ê²€ì¦
        const birthDateDigits = birthDate.replace(/\D/g, '');
        if (birthDateDigits.length !== 6 && birthDateDigits.length !== 8) {
            alert('ìƒë…„ì›”ì¼ì„ 6ìë¦¬(YYMMDD) ë˜ëŠ” 8ìë¦¬(YYYYMMDD)ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }
        
        // ì„œë²„ì— ì¸ì¦ ë° ì‹ ì²­ ìš”ì²­
        try {
            const response = await fetch('/api/leave-application/apply', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    employee_name: employeeName,
                    birth_date: birthDate,
                    selected_dates: selectedDates
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert('ì‹ ì²­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                location.reload();
            } else {
                alert(result.message || 'ì‹ ì²­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('Error:', error);
            alert('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
    }
    
    getSelectedDates() {
        const checkboxes = document.querySelectorAll('.date-checkbox:checked');
        return Array.from(checkboxes).map(cb => cb.value);
    }
}

// ì´ˆê¸°í™”
document.addEventListener('DOMContentLoaded', () => {
    new LeaveApplicationForm();
});
```

**ë°±ì—”ë“œ API**:
```python
@app.route('/api/leave-application/apply', methods=['POST'])
def apply_leave():
    """ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ API"""
    try:
        data = request.get_json()
        
        # ì¸ì¦
        auth = LeaveApplicationAuth()
        auth_result = auth.authenticate_employee(
            data['employee_name'],
            data['birth_date']
        )
        
        if not auth_result['success']:
            return jsonify({
                'success': False,
                'message': auth_result['message']
            }), 401
        
        employee_id = auth_result['employee_id']
        selected_dates = data['selected_dates']
        
        # ì‹ ì²­ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        validator = LeaveApplicationValidator()
        validation_result = validator.validate_application(
            employee_id,
            selected_dates
        )
        
        if not validation_result['valid']:
            return jsonify({
                'success': False,
                'message': validation_result['message']
            }), 400
        
        # ì‹ ì²­ ì²˜ë¦¬
        application_service = LeaveApplicationService()
        result = application_service.create_application(
            employee_id,
            selected_dates,
            leave_type='ì˜¤í”„'
        )
        
        return jsonify({
            'success': True,
            'message': 'ì‹ ì²­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
            'application_id': result['application_id']
        })
        
    except Exception as e:
        logger.error(f"ì‹ ì²­ ì²˜ë¦¬ ì˜¤ë¥˜: {str(e)}")
        return jsonify({
            'success': False,
            'message': 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.'
        }), 500
```

---

## 5. UI/UX ê°œì„  ì‚¬í•­

### 5.1 ë‹¬ë ¥ í™”ë©´ì— ì•¼ê°„ ì§„ë£Œ í‘œì‹œ ì¶”ê°€

**ë³€ê²½ ë‚´ì—­**:
- ë©”ì¸ ë‹¬ë ¥ í™”ë©´ì— ì•¼ê°„ ì§„ë£Œ ì—¬ë¶€ë¥¼ ğŸŒ™ ì•„ì´ì½˜ìœ¼ë¡œ í‘œì‹œ

**êµ¬í˜„ ì½”ë“œ**:
```python
def render_calendar_cell(date_obj, schedule_data):
    """ë‹¬ë ¥ ì…€ ë Œë”ë§
    
    Returns:
        HTML ë¬¸ìì—´
    """
    # ê¸°ë³¸ ì •ë³´
    day = date_obj.day
    doctors = schedule_data.get('doctors', [])
    required_staff = schedule_data.get('required_staff', 0)
    has_night_shift = schedule_data.get('has_night_shift', False)
    
    # ì›ì¥ ì´ë¦„ ì¤„ì„ (ì„±ë§Œ í‘œì‹œ)
    doctor_display = ''.join([d.split('(')[0][0] for d in doctors[:3]])
    
    # ì•¼ê°„ ì§„ë£Œ ì•„ì´ì½˜
    night_icon = 'ğŸŒ™' if has_night_shift else ''
    
    html = f"""
    <div class="calendar-cell" data-date="{date_obj.isoformat()}">
        <div class="cell-header">
            <span class="day-number">{day}ì¼</span>
        </div>
        <div class="cell-body">
            <div class="doctors">{doctor_display}</div>
            <div class="staff-count">{required_staff}ëª…</div>
            {f'<div class="night-shift">{night_icon}</div>' if night_icon else ''}
        </div>
        <div class="cell-footer">
            <button class="edit-btn">í¸ì§‘</button>
        </div>
    </div>
    """
    
    return html
```

**CSS ìŠ¤íƒ€ì¼**:
```css
.calendar-cell {
    border: 1px solid #ddd;
    padding: 8px;
    min-height: 100px;
    position: relative;
}

.cell-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
}

.day-number {
    font-weight: bold;
    font-size: 14px;
}

.cell-body {
    margin-bottom: 8px;
}

.doctors {
    font-size: 13px;
    color: #333;
    margin-bottom: 4px;
}

.staff-count {
    font-size: 12px;
    color: #666;
}

.night-shift {
    font-size: 18px;
    margin-top: 4px;
}

.edit-btn {
    padding: 4px 8px;
    font-size: 12px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.edit-btn:hover {
    background-color: #45a049;
}
```

### 5.2 ì£¼ê°„ ì˜¤í”„ í˜„í™© í‘œì‹œ ì‚­ì œ

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ì£¼ì°¨ë³„ ì˜¤í”„ í˜„í™© í‘œì‹œ
- ë³€ê²½: **ì£¼ê°„ ì˜¤í”„ í˜„í™© ì‚­ì œ** (ì›”ë³„ í˜„í™©ë§Œ í‘œì‹œ)

**ì œê±°í•  ì½”ë“œ**:
```python
# ì œê±° - ì£¼ê°„ ì˜¤í”„ í˜„í™© í•¨ìˆ˜
def get_weekly_off_status(year, month, week_number):
    """ì£¼ì°¨ë³„ ì˜¤í”„ í˜„í™© - ì‚­ì œ"""
    pass

# ì œê±° - ì£¼ê°„ ì˜¤í”„ í˜„í™© UI ë Œë”ë§
def render_weekly_off_status():
    """ì£¼ê°„ ì˜¤í”„ í˜„í™© UI - ì‚­ì œ"""
    pass
```

**ìœ ì§€í•  ê¸°ëŠ¥**:
```python
def get_monthly_off_status(year, month):
    """ì›”ë³„ ì˜¤í”„ í˜„í™©ë§Œ ìœ ì§€
    
    Returns:
        {
            'employee_id': {
                'name': 'ì´ë¦„',
                'required_offs': 8,
                'actual_offs': 8,
                'status': 'complete'  # complete, insufficient, excess
            }
        }
    """
    employees = Employee.query.filter_by(is_active=True).all()
    
    status = {}
    for emp in employees:
        offs = LeaveRecord.query.filter(
            LeaveRecord.employee_id == emp.id,
            extract('year', LeaveRecord.leave_date) == year,
            extract('month', LeaveRecord.leave_date) == month,
            LeaveRecord.leave_type == 'ì˜¤í”„'
        ).count()
        
        required = 8  # ëª¨ë“  ì§ì› ì›” 8ì¼
        
        if offs == required:
            status_str = 'complete'
        elif offs < required:
            status_str = 'insufficient'
        else:
            status_str = 'excess'
        
        status[emp.id] = {
            'name': emp.name,
            'required_offs': required,
            'actual_offs': offs,
            'status': status_str
        }
    
    return status
```

---

## 6. ì£¼ì°¨ ê¸°ì¤€ ë¡œì§ ë³€ê²½

### 6.1 ì£¼ì°¨ ê³„ì‚° ë°©ì‹

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: 1ì¼ë¶€í„° ì‹œì‘í•˜ëŠ” ì£¼ì°¨ (1/1~1/7 = 1ì£¼ì°¨)
- ë³€ê²½: **ì¼ìš”ì¼~í† ìš”ì¼ ê¸°ì¤€ ì£¼ì°¨ (12/29~1/4 = 1ì£¼ì°¨)**

**êµ¬í˜„ ë¡œì§**:
```python
def get_week_number_in_month(date_obj):
    """ë‚ ì§œê°€ ì†í•œ ì›”ì˜ ì£¼ì°¨ ë²ˆí˜¸ ë°˜í™˜ (ì¼~í†  ê¸°ì¤€)
    
    Args:
        date_obj: date ê°ì²´
    
    Returns:
        int: 1~5 (í•´ë‹¹ ì›”ì˜ ì£¼ì°¨ ë²ˆí˜¸)
    
    ì˜ˆì‹œ:
        2025-01-01 (ìˆ˜) â†’ 1ì£¼ì°¨ (12/29~1/4)
        2025-01-05 (ì¼) â†’ 2ì£¼ì°¨ (1/5~1/11)
    """
    year = date_obj.year
    month = date_obj.month
    
    # í•´ë‹¹ ì›” 1ì¼ ì°¾ê¸°
    first_day = date(year, month, 1)
    
    # 1ì¼ì´ ì†í•œ ì£¼ì˜ ì¼ìš”ì¼ ì°¾ê¸°
    days_to_sunday = first_day.weekday() + 1  # ì›”=0, ì¼=6
    if days_to_sunday == 7:
        days_to_sunday = 0
    
    first_sunday = first_day - timedelta(days=days_to_sunday)
    
    # ì…ë ¥ ë‚ ì§œê°€ ì†í•œ ì£¼ì˜ ì¼ìš”ì¼ ì°¾ê¸°
    days_since_sunday = date_obj.weekday() + 1
    if days_since_sunday == 7:
        days_since_sunday = 0
    
    target_sunday = date_obj - timedelta(days=days_since_sunday)
    
    # ì£¼ì°¨ ê³„ì‚°
    week_diff = (target_sunday - first_sunday).days // 7
    week_number = week_diff + 1
    
    return week_number

def get_week_range(year, month, week_number):
    """ì£¼ì°¨ì˜ ì‹œì‘ì¼ê³¼ ì¢…ë£Œì¼ ë°˜í™˜
    
    Returns:
        (start_date, end_date) íŠœí”Œ
    
    ì˜ˆì‹œ:
        get_week_range(2025, 1, 1) â†’ (2024-12-29, 2025-01-04)
        get_week_range(2025, 1, 2) â†’ (2025-01-05, 2025-01-11)
    """
    first_day = date(year, month, 1)
    
    # 1ì¼ì´ ì†í•œ ì£¼ì˜ ì¼ìš”ì¼
    days_to_sunday = first_day.weekday() + 1
    if days_to_sunday == 7:
        days_to_sunday = 0
    
    first_sunday = first_day - timedelta(days=days_to_sunday)
    
    # í•´ë‹¹ ì£¼ì°¨ì˜ ì¼ìš”ì¼
    week_sunday = first_sunday + timedelta(weeks=week_number - 1)
    week_saturday = week_sunday + timedelta(days=6)
    
    return (week_sunday, week_saturday)
```

### 6.2 ì²« í”„ë¡œê·¸ë¨ ì„¤ì • ì‹œ 1ì£¼ì°¨ í¬í•¨

**ë³€ê²½ ë‚´ì—­**:
- ì²« ì„¤ì • ì‹œ 1ì£¼ì°¨ê°€ ì´ì „ ì›” í¬í•¨ë˜ì–´ë„ ë°°ì¹˜ ê°€ëŠ¥

**êµ¬í˜„ ë¡œì§**:
```python
def is_first_time_setup(year, month):
    """í•´ë‹¹ ì›”ì´ ìµœì´ˆ ì„¤ì •ì¸ì§€ í™•ì¸"""
    existing_schedules = DailySchedule.query.filter(
        extract('year', DailySchedule.schedule_date) == year,
        extract('month', DailySchedule.schedule_date) == month
    ).count()
    
    return existing_schedules == 0

def get_assignable_weeks(year, month):
    """ë°°ì¹˜ ê°€ëŠ¥í•œ ì£¼ì°¨ ëª©ë¡
    
    Returns:
        List of week numbers
    """
    is_first_setup = is_first_time_setup(year, month)
    
    weeks = self.get_weeks_in_month(year, month)
    confirmations = ScheduleConfirmation.query.filter_by(
        year=year,
        month=month,
        is_confirmed=True
    ).all()
    
    confirmed_week_numbers = {conf.week_number for conf in confirmations}
    
    assignable = []
    for week_num in weeks.keys():
        # í™•ì •ëœ ì£¼ì°¨ëŠ” ì œì™¸
        if week_num in confirmed_week_numbers:
            continue
        
        # ì²« ì„¤ì •ì´ ì•„ë‹ˆë©´ 1ì£¼ì°¨ ì œì™¸ (ì´ì „ ì›” í¬í•¨)
        if not is_first_setup and week_num == 1:
            week_range = get_week_range(year, month, week_num)
            # 1ì£¼ì°¨ê°€ ì „ë¶€ í˜„ì¬ ì›”ì— ì†í•˜ë©´ í¬í•¨
            if week_range[0].month == month:
                assignable.append(week_num)
        else:
            assignable.append(week_num)
    
    return assignable
```

---

## 7. í†µê³„ ë° í˜„í™© í‘œì‹œ ë°©ì‹

### 7.1 ì›”ë³„ ê¸°ì¤€ìœ¼ë¡œ í†µì¼

**ë³€ê²½ ë‚´ì—­**:
- í˜„í™© ë° í†µê³„ëŠ” **ì‹¤ì œ ì›” ê¸°ì¤€ (1ì¼~ë§ì¼)**ìœ¼ë¡œë§Œ í‘œì‹œ

**í†µê³„ ì¿¼ë¦¬**:
```python
class MonthlyStatistics:
    """ì›”ë³„ í†µê³„"""
    
    def get_monthly_stats(self, year, month):
        """ì›”ë³„ ì¢…í•© í†µê³„
        
        Returns:
            {
                'work_days': int,              # ì´ ê·¼ë¬´ì¼
                'night_shifts': int,           # ì•¼ê°„ ì§„ë£Œì¼
                'average_staff': float,        # í‰ê·  í•„ìš” ì¸ì›
                'staff_distribution': dict,    # ì§ì›ë³„ ê·¼ë¬´ ì¼ìˆ˜
                'off_distribution': dict       # ì§ì›ë³„ ì˜¤í”„ ì¼ìˆ˜
            }
        """
        # í•´ë‹¹ ì›”ì˜ ëª¨ë“  ìŠ¤ì¼€ì¤„ ì¡°íšŒ
        schedules = DailySchedule.query.filter(
            extract('year', DailySchedule.schedule_date) == year,
            extract('month', DailySchedule.schedule_date) == month
        ).all()
        
        total_work_days = len(schedules)
        night_shift_days = sum(1 for s in schedules if s.has_night_shift)
        avg_staff = sum(s.required_staff for s in schedules) / total_work_days if total_work_days > 0 else 0
        
        # ì§ì›ë³„ ê·¼ë¬´ ì¼ìˆ˜
        staff_work_days = {}
        for schedule in schedules:
            assignments = StaffAssignment.query.filter_by(
                schedule_id=schedule.id
            ).all()
            
            for assignment in assignments:
                emp_id = assignment.employee_id
                if emp_id not in staff_work_days:
                    staff_work_days[emp_id] = 0
                staff_work_days[emp_id] += 1
        
        # ì§ì›ë³„ ì˜¤í”„ ì¼ìˆ˜
        off_days = {}
        employees = Employee.query.filter_by(is_active=True).all()
        
        for emp in employees:
            offs = LeaveRecord.query.filter(
                LeaveRecord.employee_id == emp.id,
                extract('year', LeaveRecord.leave_date) == year,
                extract('month', LeaveRecord.leave_date) == month,
                LeaveRecord.leave_type == 'ì˜¤í”„'
            ).count()
            
            off_days[emp.id] = {
                'name': emp.name,
                'count': offs
            }
        
        return {
            'year': year,
            'month': month,
            'work_days': total_work_days,
            'night_shifts': night_shift_days,
            'night_shift_rate': (night_shift_days / total_work_days * 100) if total_work_days > 0 else 0,
            'average_staff': round(avg_staff, 1),
            'staff_distribution': staff_work_days,
            'off_distribution': off_days
        }

### 7.2 í˜•í‰ì„± ë¶„ì„ (ì—°ë‹¨ìœ„, ëˆ„ì  ëª©í‘œ ê¸°ë°˜)

**ë³€ê²½ ë‚´ì—­**:
- ê¸°ì¡´: ì›”ë³„ í˜•í‰ì„± ë¶„ì„
- ë³€ê²½: **ì—°ë‹¨ìœ„ í˜•í‰ì„± ë¶„ì„ (ëˆ„ì  ëª©í‘œ ê¸°ë°˜)**

**í•µì‹¬ ë¡œì§**:
- ì‹¤ì œ ìŠ¤ì¼€ì¤„ ê¸°ë°˜ìœ¼ë¡œ ì›”ë³„ ëˆ„ì  ëª©í‘œ ê³„ì‚°
- í˜„ì¬ ì‹¤ì ê³¼ ëˆ„ì  ëª©í‘œ ë¹„êµ
- ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡±í•œ ì§ì› ìš°ì„  ë°°ì •

**êµ¬í˜„ ì½”ë“œ**:
```python
class YearlyFairnessAnalysis:
    """ì—°ë‹¨ìœ„ í˜•í‰ì„± ë¶„ì„ (ëˆ„ì  ëª©í‘œ ê¸°ë°˜)"""
    
    def calculate_cumulative_target(self, year, month, shift_type='night'):
        """ëˆ„ì  ëª©í‘œ ê³„ì‚° (í•´ë‹¹ ì›”ê¹Œì§€)
        
        Args:
            year: ì—°ë„
            month: ì›” (1~12)
            shift_type: 'night' (ì•¼ê°„) ë˜ëŠ” 'weekend' (ì£¼ë§)
        
        Returns:
            {
                'total_shifts': int,           # ëˆ„ì  ì´ ì•¼ê°„/ì£¼ë§ ì¼ìˆ˜
                'total_needs': int,            # ëˆ„ì  ì´ í•„ìš” ì¸ì›
                'target_per_employee': float,  # ì§ì› 1ì¸ë‹¹ ëˆ„ì  ëª©í‘œ
                'breakdown': [...]             # ì›”ë³„ ìƒì„¸
            }
        """
        total_shifts = 0
        total_needs = 0
        breakdown = []
        
        for m in range(1, month + 1):
            if shift_type == 'night':
                # í•´ë‹¹ ì›”ì˜ ì•¼ê°„ ì§„ë£Œì¼ ì¡°íšŒ
                schedules = DailySchedule.query.filter(
                    extract('year', DailySchedule.schedule_date) == year,
                    extract('month', DailySchedule.schedule_date) == m,
                    DailySchedule.has_night_shift == True
                ).all()
            else:  # weekend
                # í•´ë‹¹ ì›”ì˜ ì£¼ë§ ê·¼ë¬´ì¼ ì¡°íšŒ
                schedules = DailySchedule.query.filter(
                    extract('year', DailySchedule.schedule_date) == year,
                    extract('month', DailySchedule.schedule_date) == m,
                    extract('dow', DailySchedule.schedule_date).in_([0, 6])  # ì¼=0, í† =6
                ).all()
            
            month_shifts = len(schedules)
            month_needs = sum(s.required_staff for s in schedules)
            
            total_shifts += month_shifts
            total_needs += month_needs
            
            breakdown.append({
                'month': m,
                'shifts': month_shifts,
                'needs': month_needs
            })
        
        # í™œì„± ì§ì› ìˆ˜
        active_employees = Employee.query.filter_by(is_active=True).count()
        
        # ì§ì› 1ì¸ë‹¹ ëª©í‘œ
        target_per_employee = total_needs / active_employees if active_employees > 0 else 0
        
        return {
            'year': year,
            'month': month,
            'total_shifts': total_shifts,
            'total_needs': total_needs,
            'active_employees': active_employees,
            'target_per_employee': round(target_per_employee, 2),
            'breakdown': breakdown
        }
    
    def get_night_shift_fairness(self, year, month):
        """ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„± ë¶„ì„
        
        Returns:
            {
                'cumulative_target': {...},    # ëˆ„ì  ëª©í‘œ
                'employees': {
                    employee_id: {
                        'name': str,
                        'current_count': int,      # í˜„ì¬ê¹Œì§€ ì‹¤ì 
                        'target': float,           # ëˆ„ì  ëª©í‘œ
                        'diff': float,             # ì°¨ì´ (ìŒìˆ˜=ë¶€ì¡±, ì–‘ìˆ˜=ì´ˆê³¼)
                        'priority': float,         # ìš°ì„ ìˆœìœ„ (ë‚®ì„ìˆ˜ë¡ ìš°ì„ )
                        'status': str              # 'behind', 'on_track', 'ahead'
                    }
                }
            }
        """
        # ëˆ„ì  ëª©í‘œ ê³„ì‚°
        cumulative_target = self.calculate_cumulative_target(year, month, 'night')
        target = cumulative_target['target_per_employee']
        
        # ì§ì›ë³„ ì‹¤ì  ì¡°íšŒ
        employees = Employee.query.filter_by(is_active=True).all()
        employee_data = {}
        
        for emp in employees:
            # í•´ë‹¹ ì›”ê¹Œì§€ì˜ ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜
            current_count = db.session.query(StaffAssignment).join(DailySchedule).filter(
                StaffAssignment.employee_id == emp.id,
                extract('year', DailySchedule.schedule_date) == year,
                extract('month', DailySchedule.schedule_date) <= month,
                DailySchedule.has_night_shift == True,
                StaffAssignment.status == 'assigned'
            ).count()
            
            diff = current_count - target
            
            # ìƒíƒœ íŒì •
            if diff < -2:
                status = 'behind'       # 2íšŒ ì´ìƒ ë¶€ì¡±
            elif diff > 2:
                status = 'ahead'        # 2íšŒ ì´ìƒ ì´ˆê³¼
            else:
                status = 'on_track'     # ì ì • ë²”ìœ„
            
            employee_data[emp.id] = {
                'name': emp.name,
                'current_count': current_count,
                'target': target,
                'diff': round(diff, 2),
                'priority': diff,  # ìš°ì„ ìˆœìœ„ = ì°¨ì´ê°’ (ìŒìˆ˜ì¼ìˆ˜ë¡ ìš°ì„ )
                'status': status
            }
        
        return {
            'year': year,
            'month': month,
            'cumulative_target': cumulative_target,
            'employees': employee_data
        }
    
    def get_weekend_work_fairness(self, year, month):
        """ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„± ë¶„ì„
        
        Returns:
            ë™ì¼í•œ êµ¬ì¡° (ì•¼ê°„ ê·¼ë¬´ì™€ ìœ ì‚¬)
        """
        # ëˆ„ì  ëª©í‘œ ê³„ì‚°
        cumulative_target = self.calculate_cumulative_target(year, month, 'weekend')
        target = cumulative_target['target_per_employee']
        
        # ì§ì›ë³„ ì‹¤ì  ì¡°íšŒ
        employees = Employee.query.filter_by(is_active=True).all()
        employee_data = {}
        
        for emp in employees:
            # í•´ë‹¹ ì›”ê¹Œì§€ì˜ ì£¼ë§ ê·¼ë¬´ íšŸìˆ˜
            current_count = db.session.query(StaffAssignment).join(DailySchedule).filter(
                StaffAssignment.employee_id == emp.id,
                extract('year', DailySchedule.schedule_date) == year,
                extract('month', DailySchedule.schedule_date) <= month,
                extract('dow', DailySchedule.schedule_date).in_([0, 6]),
                StaffAssignment.status == 'assigned'
            ).count()
            
            diff = current_count - target
            
            # ìƒíƒœ íŒì •
            if diff < -2:
                status = 'behind'
            elif diff > 2:
                status = 'ahead'
            else:
                status = 'on_track'
            
            employee_data[emp.id] = {
                'name': emp.name,
                'current_count': current_count,
                'target': target,
                'diff': round(diff, 2),
                'priority': diff,
                'status': status
            }
        
        return {
            'year': year,
            'month': month,
            'cumulative_target': cumulative_target,
            'employees': employee_data
        }
    
    def get_comprehensive_fairness_report(self, year, month):
        """ì¢…í•© í˜•í‰ì„± ë¦¬í¬íŠ¸
        
        Returns:
            {
                'year': int,
                'month': int,
                'night_shift': {...},     # ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„±
                'weekend_work': {...},    # ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„±
                'recommendations': [...]  # ê¶Œì¥ ì‚¬í•­
            }
        """
        night_shift_fairness = self.get_night_shift_fairness(year, month)
        weekend_fairness = self.get_weekend_work_fairness(year, month)
        
        # ê¶Œì¥ ì‚¬í•­ ìƒì„±
        recommendations = self.generate_recommendations(
            night_shift_fairness,
            weekend_fairness
        )
        
        return {
            'year': year,
            'month': month,
            'night_shift': night_shift_fairness,
            'weekend_work': weekend_fairness,
            'recommendations': recommendations
        }
    
    def generate_recommendations(self, night_fairness, weekend_fairness):
        """ê¶Œì¥ ì‚¬í•­ ìƒì„±"""
        recommendations = []
        
        # ì•¼ê°„ ê·¼ë¬´ ê¶Œì¥
        night_behind = [
            (emp_id, data) for emp_id, data in night_fairness['employees'].items()
            if data['status'] == 'behind'
        ]
        
        if night_behind:
            # ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ (ì°¨ì´ê°€ í° ìˆœ)
            night_behind.sort(key=lambda x: x[1]['priority'])
            names = [data['name'] for _, data in night_behind[:5]]  # ìƒìœ„ 5ëª…
            
            recommendations.append({
                'type': 'night_shift_priority',
                'priority': 'high',
                'message': f"ì•¼ê°„ ê·¼ë¬´ ìš°ì„  ë°°ì • ê¶Œì¥: {', '.join(names)}",
                'employee_ids': [emp_id for emp_id, _ in night_behind[:5]],
                'details': f"ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡± ì¸ì› {len(night_behind)}ëª…"
            })
        
        night_ahead = [
            (emp_id, data) for emp_id, data in night_fairness['employees'].items()
            if data['status'] == 'ahead'
        ]
        
        if night_ahead:
            names = [data['name'] for _, data in night_ahead[:5]]
            recommendations.append({
                'type': 'night_shift_reduce',
                'priority': 'medium',
                'message': f"ì•¼ê°„ ê·¼ë¬´ ë°°ì • ìì œ ê¶Œì¥: {', '.join(names)}",
                'employee_ids': [emp_id for emp_id, _ in night_ahead[:5]],
                'details': f"ëª©í‘œ ì´ˆê³¼ ì¸ì› {len(night_ahead)}ëª…"
            })
        
        # ì£¼ë§ ê·¼ë¬´ ê¶Œì¥
        weekend_behind = [
            (emp_id, data) for emp_id, data in weekend_fairness['employees'].items()
            if data['status'] == 'behind'
        ]
        
        if weekend_behind:
            weekend_behind.sort(key=lambda x: x[1]['priority'])
            names = [data['name'] for _, data in weekend_behind[:5]]
            
            recommendations.append({
                'type': 'weekend_priority',
                'priority': 'high',
                'message': f"ì£¼ë§ ê·¼ë¬´ ìš°ì„  ë°°ì • ê¶Œì¥: {', '.join(names)}",
                'employee_ids': [emp_id for emp_id, _ in weekend_behind[:5]],
                'details': f"ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡± ì¸ì› {len(weekend_behind)}ëª…"
            })
        
        # í˜•í‰ì„± ë‹¬ì„±
        night_on_track = sum(
            1 for data in night_fairness['employees'].values()
            if data['status'] == 'on_track'
        )
        total_employees = len(night_fairness['employees'])
        
        if night_on_track / total_employees > 0.8:
            recommendations.append({
                'type': 'achievement',
                'priority': 'info',
                'message': f'ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„± ìš°ìˆ˜! ({night_on_track}/{total_employees}ëª… ì ì • ë²”ìœ„) ğŸ‰',
                'employee_ids': []
            })
        
        return recommendations
```

**ìë™ ë°°ì¹˜ ì‹œ í˜•í‰ì„± ì ìš©**:
```python
class FairScheduleAssigner:
    """í˜•í‰ì„± ê¸°ë°˜ ìë™ ë°°ì¹˜"""
    
    def __init__(self, year, month):
        self.year = year
        self.month = month
        self.fairness_analyzer = YearlyFairnessAnalysis()
    
    def assign_staff_with_fairness(self, schedule_date, required_staff):
        """í˜•í‰ì„±ì„ ê³ ë ¤í•œ ì§ì› ë°°ì¹˜
        
        Args:
            schedule_date: ë°°ì¹˜í•  ë‚ ì§œ
            required_staff: í•„ìš” ì¸ì› ìˆ˜
        
        Returns:
            List[int]: ë°°ì¹˜ëœ ì§ì› ID ëª©ë¡
        """
        schedule = DailySchedule.query.filter_by(schedule_date=schedule_date).first()
        
        # ì´ë¯¸ ì˜¤í”„/ì—°ì°¨ì¸ ì§ì› ì œì™¸
        unavailable = self.get_unavailable_employees(schedule_date)
        
        # ì‚¬ìš© ê°€ëŠ¥í•œ ì§ì› ëª©ë¡
        all_employees = Employee.query.filter_by(is_active=True).all()
        available_employees = [
            emp.id for emp in all_employees
            if emp.id not in unavailable
        ]
        
        # ì•¼ê°„ ì§„ë£Œì¸ ê²½ìš° í˜•í‰ì„± ì ìš©
        if schedule.has_night_shift:
            fairness = self.fairness_analyzer.get_night_shift_fairness(
                self.year, 
                schedule_date.month
            )
            
            # ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì •ë ¬ (ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡±í•œ ìˆœ)
            priority_list = []
            for emp_id in available_employees:
                emp_data = fairness['employees'].get(emp_id)
                if emp_data:
                    priority_list.append((emp_id, emp_data['priority']))
            
            # ìš°ì„ ìˆœìœ„ ë‚®ì€ ìˆœ ì •ë ¬ (ìŒìˆ˜ê°€ ìš°ì„ )
            priority_list.sort(key=lambda x: x[1])
            
            # í•„ìš” ì¸ì›ë§Œí¼ ì„ íƒ
            selected = [emp_id for emp_id, _ in priority_list[:required_staff]]
            
            # ë¶€ì¡±í•˜ë©´ ë‚˜ë¨¸ì§€ ì§ì› ì¶”ê°€
            if len(selected) < required_staff:
                remaining = [emp_id for emp_id in available_employees if emp_id not in selected]
                selected.extend(remaining[:required_staff - len(selected)])
            
            return selected
        
        # ì£¼ë§ì¸ ê²½ìš°
        elif schedule_date.weekday() in [5, 6]:  # í† , ì¼
            fairness = self.fairness_analyzer.get_weekend_work_fairness(
                self.year,
                schedule_date.month
            )
            
            # ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì •ë ¬
            priority_list = []
            for emp_id in available_employees:
                emp_data = fairness['employees'].get(emp_id)
                if emp_data:
                    priority_list.append((emp_id, emp_data['priority']))
            
            priority_list.sort(key=lambda x: x[1])
            selected = [emp_id for emp_id, _ in priority_list[:required_staff]]
            
            if len(selected) < required_staff:
                remaining = [emp_id for emp_id in available_employees if emp_id not in selected]
                selected.extend(remaining[:required_staff - len(selected)])
            
            return selected
        
        # ì¼ë°˜ ê·¼ë¬´ì¼ (í‰ì¼)
        else:
            # ëœë¤ ë˜ëŠ” ë‹¤ë¥¸ ë¡œì§
            import random
            if len(available_employees) <= required_staff:
                return available_employees
            return random.sample(available_employees, required_staff)
    
    def get_unavailable_employees(self, date_obj):
        """í•´ë‹¹ ë‚ ì§œì— ë°°ì¹˜ ë¶ˆê°€ëŠ¥í•œ ì§ì› ëª©ë¡"""
        leaves = LeaveRecord.query.filter_by(
            leave_date=date_obj
        ).all()
        
        return [leave.employee_id for leave in leaves]
```

**UI í‘œì‹œ**:
```python
def render_fairness_dashboard(year, month):
    """í˜•í‰ì„± ëŒ€ì‹œë³´ë“œ ë Œë”ë§"""
    analyzer = YearlyFairnessAnalysis()
    report = analyzer.get_comprehensive_fairness_report(year, month)
    
    html = f"""
    <div class="fairness-dashboard">
        <h2>{year}ë…„ {month}ì›” í˜•í‰ì„± ë¶„ì„</h2>
        
        <div class="section">
            <h3>ì•¼ê°„ ê·¼ë¬´ í˜„í™©</h3>
            <div class="target-info">
                <p><strong>{month}ì›”ê¹Œì§€ ëˆ„ì  ëª©í‘œ:</strong> {report['night_shift']['cumulative_target']['target_per_employee']:.1f}íšŒ/ì¸</p>
                <p>ì´ ì•¼ê°„ ì¼ìˆ˜: {report['night_shift']['cumulative_target']['total_shifts']}ì¼</p>
                <p>ì´ í•„ìš” ì¸ì›: {report['night_shift']['cumulative_target']['total_needs']}ì¸-ì¼</p>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>ì§ì›ëª…</th>
                        <th>í˜„ì¬ ì‹¤ì </th>
                        <th>ëˆ„ì  ëª©í‘œ</th>
                        <th>ì°¨ì´</th>
                        <th>ìƒíƒœ</th>
                    </tr>
                </thead>
                <tbody>
    """
    
    # ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬
    sorted_employees = sorted(
        report['night_shift']['employees'].items(),
        key=lambda x: x[1]['priority']
    )
    
    for emp_id, data in sorted_employees:
        status_map = {
            'behind': 'ğŸ”´ ë¶€ì¡±',
            'on_track': 'ğŸŸ¢ ì ì •',
            'ahead': 'ğŸŸ¡ ì´ˆê³¼'
        }
        
        status_class = data['status']
        diff_display = f"{data['diff']:+.1f}íšŒ"
        
        html += f"""
                    <tr class="status-{status_class}">
                        <td>{data['name']}</td>
                        <td>{data['current_count']}íšŒ</td>
                        <td>{data['target']:.1f}íšŒ</td>
                        <td>{diff_display}</td>
                        <td>{status_map[data['status']]}</td>
                    </tr>
        """
    
    html += """
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <h3>ì£¼ë§ ê·¼ë¬´ í˜„í™©</h3>
            <div class="target-info">
                <p><strong>""" + str(month) + """ì›”ê¹Œì§€ ëˆ„ì  ëª©í‘œ:</strong> """ + f"{report['weekend_work']['cumulative_target']['target_per_employee']:.1f}" + """íšŒ/ì¸</p>
                <p>ì´ ì£¼ë§ ì¼ìˆ˜: """ + str(report['weekend_work']['cumulative_target']['total_shifts']) + """ì¼</p>
            </div>
            <table>
                <thead>
                    <tr>
                        <th>ì§ì›ëª…</th>
                        <th>í˜„ì¬ ì‹¤ì </th>
                        <th>ëˆ„ì  ëª©í‘œ</th>
                        <th>ì°¨ì´</th>
                        <th>ìƒíƒœ</th>
                    </tr>
                </thead>
                <tbody>
    """
    
    sorted_employees = sorted(
        report['weekend_work']['employees'].items(),
        key=lambda x: x[1]['priority']
    )
    
    for emp_id, data in sorted_employees:
        status_map = {
            'behind': 'ğŸ”´ ë¶€ì¡±',
            'on_track': 'ğŸŸ¢ ì ì •',
            'ahead': 'ğŸŸ¡ ì´ˆê³¼'
        }
        
        status_class = data['status']
        diff_display = f"{data['diff']:+.1f}íšŒ"
        
        html += f"""
                    <tr class="status-{status_class}">
                        <td>{data['name']}</td>
                        <td>{data['current_count']}íšŒ</td>
                        <td>{data['target']:.1f}íšŒ</td>
                        <td>{diff_display}</td>
                        <td>{status_map[data['status']]}</td>
                    </tr>
        """
    
    html += """
                </tbody>
            </table>
        </div>
        
        <div class="section recommendations">
            <h3>ğŸ’¡ ê¶Œì¥ ì‚¬í•­</h3>
            <ul>
    """
    
    for rec in report['recommendations']:
        priority_class = f"priority-{rec['priority']}"
        html += f"""
                <li class="{priority_class}">
                    <strong>{rec['message']}</strong>
                    {f"<br><small>{rec['details']}</small>" if rec.get('details') else ''}
                </li>
        """
    
    html += """
            </ul>
        </div>
        
        <div class="info-box">
            <h4>ğŸ“Š í˜•í‰ì„± ê¸°ì¤€</h4>
            <ul>
                <li>ğŸŸ¢ ì ì •: ëª©í‘œ ëŒ€ë¹„ Â±2íšŒ ì´ë‚´</li>
                <li>ğŸ”´ ë¶€ì¡±: ëª©í‘œë³´ë‹¤ 2íšŒ ì´ìƒ ì ìŒ â†’ ìš°ì„  ë°°ì •</li>
                <li>ğŸŸ¡ ì´ˆê³¼: ëª©í‘œë³´ë‹¤ 2íšŒ ì´ìƒ ë§ìŒ â†’ ë°°ì • ìì œ</li>
            </ul>
            <p><small>* ëª©í‘œëŠ” ì‹¤ì œ ìŠ¤ì¼€ì¤„ ê¸°ë°˜ìœ¼ë¡œ ë§¤ì›” ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.</small></p>
        </div>
    </div>
    """
    
    return html
```

**ì˜ˆì‹œ ì‹œë‚˜ë¦¬ì˜¤**:
```python
# 6ì›” í˜„ì¬ ìƒí™©
analyzer = YearlyFairnessAnalysis()
report = analyzer.get_comprehensive_fairness_report(2025, 6)

# ì¶œë ¥ ì˜ˆì‹œ:
"""
2025ë…„ 6ì›” í˜•í‰ì„± ë¶„ì„

ì•¼ê°„ ê·¼ë¬´ í˜„í™©:
6ì›”ê¹Œì§€ ëˆ„ì  ëª©í‘œ: 35.2íšŒ/ì¸
ì´ ì•¼ê°„ ì¼ìˆ˜: 50ì¼
ì´ í•„ìš” ì¸ì›: 700ì¸-ì¼ (50ì¼ Ã— 14ëª…)
í™œì„± ì§ì›: 20ëª…

ì§ì›ë³„ í˜„í™©:
A: í˜„ì¬ 30íšŒ, ëª©í‘œ 35.2íšŒ, ì°¨ì´ -5.2íšŒ, ğŸ”´ ë¶€ì¡±  â† ìµœìš°ì„  ë°°ì •
B: í˜„ì¬ 33íšŒ, ëª©í‘œ 35.2íšŒ, ì°¨ì´ -2.2íšŒ, ğŸ”´ ë¶€ì¡±
C: í˜„ì¬ 35íšŒ, ëª©í‘œ 35.2íšŒ, ì°¨ì´ -0.2íšŒ, ğŸŸ¢ ì ì •
D: í˜„ì¬ 37íšŒ, ëª©í‘œ 35.2íšŒ, ì°¨ì´ +1.8íšŒ, ğŸŸ¢ ì ì •
E: í˜„ì¬ 40íšŒ, ëª©í‘œ 35.2íšŒ, ì°¨ì´ +4.8íšŒ, ğŸŸ¡ ì´ˆê³¼  â† ë°°ì • ìì œ

ê¶Œì¥ ì‚¬í•­:
- ì•¼ê°„ ê·¼ë¬´ ìš°ì„  ë°°ì • ê¶Œì¥: A, B (ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡±)
- ì•¼ê°„ ê·¼ë¬´ ë°°ì • ìì œ ê¶Œì¥: E (ëª©í‘œ ì´ˆê³¼)
"""
```
```python
class YearlyFairnessAnalysis:
    """ì—°ë‹¨ìœ„ í˜•í‰ì„± ë¶„ì„"""
    
    def get_night_shift_fairness(self, year):
        """ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„± ë¶„ì„ (ìµœëŒ€ íˆ¬ì…ì¼ ê¸°ì¤€)
        
        Returns:
            {
                'max_count': int,              # ìµœëŒ€ ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜
                'employees': {
                    employee_id: {
                        'name': str,
                        'count': int,          # í˜„ì¬ ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜
                        'is_maxed': bool,      # ìµœëŒ€ ë„ë‹¬ ì—¬ë¶€
                        'can_assign': bool     # ë°°ì • ê°€ëŠ¥ ì—¬ë¶€
                    }
                }
            }
        """
        employees = Employee.query.filter_by(is_active=True).all()
        
        # ê° ì§ì›ì˜ ì—°ê°„ ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜ ì¡°íšŒ
        night_shift_counts = {}
        
        for emp in employees:
            # ì—°ê°„ ì•¼ê°„ ê·¼ë¬´ê°€ ìˆëŠ” ë‚ ì§œì˜ ë°°ì¹˜ ì¡°íšŒ
            count = db.session.query(StaffAssignment).join(DailySchedule).filter(
                StaffAssignment.employee_id == emp.id,
                extract('year', DailySchedule.schedule_date) == year,
                DailySchedule.has_night_shift == True,
                StaffAssignment.status == 'assigned'
            ).count()
            
            night_shift_counts[emp.id] = {
                'name': emp.name,
                'count': count,
                'is_maxed': False,
                'can_assign': True
            }
        
        # ìµœëŒ€ ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜ ì°¾ê¸°
        if night_shift_counts:
            max_count = max(data['count'] for data in night_shift_counts.values())
        else:
            max_count = 0
        
        # ìµœëŒ€ ë„ë‹¬ ì—¬ë¶€ ë° ë°°ì • ê°€ëŠ¥ ì—¬ë¶€ ì„¤ì •
        for emp_id, data in night_shift_counts.items():
            data['is_maxed'] = (data['count'] >= max_count)
            data['can_assign'] = (data['count'] < max_count)
        
        return {
            'year': year,
            'max_count': max_count,
            'employees': night_shift_counts
        }
    
    def get_assignable_employees_for_night_shift(self, year):
        """ì•¼ê°„ ê·¼ë¬´ ë°°ì • ê°€ëŠ¥í•œ ì§ì› ëª©ë¡
        
        Returns:
            List[int]: ë°°ì • ê°€ëŠ¥í•œ ì§ì› ID ëª©ë¡
        """
        fairness = self.get_night_shift_fairness(year)
        
        assignable = []
        for emp_id, data in fairness['employees'].items():
            if data['can_assign']:
                assignable.append(emp_id)
        
        return assignable
    
    def get_weekend_work_fairness(self, year):
        """ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„± ë¶„ì„ (ìµœëŒ€ íˆ¬ì…ì¼ ê¸°ì¤€)
        
        Returns:
            ë™ì¼í•œ êµ¬ì¡° (ì•¼ê°„ ê·¼ë¬´ì™€ ìœ ì‚¬)
        """
        employees = Employee.query.filter_by(is_active=True).all()
        
        weekend_work_counts = {}
        
        for emp in employees:
            # ì—°ê°„ ì£¼ë§ ê·¼ë¬´ (í† ìš”ì¼, ì¼ìš”ì¼) íšŸìˆ˜ ì¡°íšŒ
            count = db.session.query(StaffAssignment).join(DailySchedule).filter(
                StaffAssignment.employee_id == emp.id,
                extract('year', DailySchedule.schedule_date) == year,
                extract('dow', DailySchedule.schedule_date).in_([0, 6]),  # ì¼=0, í† =6
                StaffAssignment.status == 'assigned'
            ).count()
            
            weekend_work_counts[emp.id] = {
                'name': emp.name,
                'count': count,
                'is_maxed': False,
                'can_assign': True
            }
        
        # ìµœëŒ€ ì£¼ë§ ê·¼ë¬´ íšŸìˆ˜
        if weekend_work_counts:
            max_count = max(data['count'] for data in weekend_work_counts.values())
        else:
            max_count = 0
        
        # ìµœëŒ€ ë„ë‹¬ ì—¬ë¶€ ì„¤ì •
        for emp_id, data in weekend_work_counts.items():
            data['is_maxed'] = (data['count'] >= max_count)
            data['can_assign'] = (data['count'] < max_count)
        
        return {
            'year': year,
            'max_count': max_count,
            'employees': weekend_work_counts
        }
    
    def get_comprehensive_fairness_report(self, year):
        """ì¢…í•© í˜•í‰ì„± ë¦¬í¬íŠ¸
        
        Returns:
            {
                'year': int,
                'night_shift': {...},     # ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„±
                'weekend_work': {...},    # ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„±
                'total_work_days': {...}, # ì´ ê·¼ë¬´ì¼ìˆ˜
                'recommendations': [...]  # ê¶Œì¥ ì‚¬í•­
            }
        """
        night_shift_fairness = self.get_night_shift_fairness(year)
        weekend_fairness = self.get_weekend_work_fairness(year)
        
        # ì´ ê·¼ë¬´ì¼ìˆ˜ ê³„ì‚°
        employees = Employee.query.filter_by(is_active=True).all()
        total_work_days = {}
        
        for emp in employees:
            count = StaffAssignment.query.join(DailySchedule).filter(
                StaffAssignment.employee_id == emp.id,
                extract('year', DailySchedule.schedule_date) == year,
                StaffAssignment.status == 'assigned'
            ).count()
            
            total_work_days[emp.id] = {
                'name': emp.name,
                'count': count
            }
        
        # ê¶Œì¥ ì‚¬í•­ ìƒì„±
        recommendations = self.generate_recommendations(
            night_shift_fairness,
            weekend_fairness,
            total_work_days
        )
        
        return {
            'year': year,
            'night_shift': night_shift_fairness,
            'weekend_work': weekend_fairness,
            'total_work_days': total_work_days,
            'recommendations': recommendations
        }
    
    def generate_recommendations(self, night_fairness, weekend_fairness, total_days):
        """ê¶Œì¥ ì‚¬í•­ ìƒì„±"""
        recommendations = []
        
        # ì•¼ê°„ ê·¼ë¬´ ê¶Œì¥
        night_can_assign = [
            emp_id for emp_id, data in night_fairness['employees'].items()
            if data['can_assign']
        ]
        
        if night_can_assign:
            names = [night_fairness['employees'][emp_id]['name'] for emp_id in night_can_assign]
            recommendations.append({
                'type': 'night_shift',
                'priority': 'high',
                'message': f"ë‹¤ìŒ ì§ì›ë“¤ì€ ì•¼ê°„ ê·¼ë¬´ ë°°ì • ê°€ëŠ¥: {', '.join(names)}",
                'employee_ids': night_can_assign
            })
        
        # ì£¼ë§ ê·¼ë¬´ ê¶Œì¥
        weekend_can_assign = [
            emp_id for emp_id, data in weekend_fairness['employees'].items()
            if data['can_assign']
        ]
        
        if weekend_can_assign:
            names = [weekend_fairness['employees'][emp_id]['name'] for emp_id in weekend_can_assign]
            recommendations.append({
                'type': 'weekend_work',
                'priority': 'medium',
                'message': f"ë‹¤ìŒ ì§ì›ë“¤ì€ ì£¼ë§ ê·¼ë¬´ ë°°ì • ê°€ëŠ¥: {', '.join(names)}",
                'employee_ids': weekend_can_assign
            })
        
        # í˜•í‰ì„± ë‹¬ì„± ì‹œ
        if not night_can_assign:
            recommendations.append({
                'type': 'achievement',
                'priority': 'info',
                'message': 'ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„±ì´ ì™„ë²½í•˜ê²Œ ë‹¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰',
                'employee_ids': []
            })
        
        if not weekend_can_assign:
            recommendations.append({
                'type': 'achievement',
                'priority': 'info',
                'message': 'ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„±ì´ ì™„ë²½í•˜ê²Œ ë‹¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰',
                'employee_ids': []
            })
        
        return recommendations
```

**ìë™ ë°°ì¹˜ ì‹œ í˜•í‰ì„± ì ìš©**:
```python
class FairScheduleAssigner:
    """í˜•í‰ì„± ê¸°ë°˜ ìë™ ë°°ì¹˜"""
    
    def __init__(self, year):
        self.year = year
        self.fairness_analyzer = YearlyFairnessAnalysis()
    
    def assign_staff_with_fairness(self, schedule_date, required_staff):
        """í˜•í‰ì„±ì„ ê³ ë ¤í•œ ì§ì› ë°°ì¹˜
        
        Args:
            schedule_date: ë°°ì¹˜í•  ë‚ ì§œ
            required_staff: í•„ìš” ì¸ì› ìˆ˜
        
        Returns:
            List[int]: ë°°ì¹˜ëœ ì§ì› ID ëª©ë¡
        """
        schedule = DailySchedule.query.filter_by(schedule_date=schedule_date).first()
        
        # ì´ë¯¸ ì˜¤í”„/ì—°ì°¨ì¸ ì§ì› ì œì™¸
        unavailable = self.get_unavailable_employees(schedule_date)
        
        # ì‚¬ìš© ê°€ëŠ¥í•œ ì§ì› ëª©ë¡
        all_employees = Employee.query.filter_by(is_active=True).all()
        available_employees = [
            emp.id for emp in all_employees
            if emp.id not in unavailable
        ]
        
        # ì•¼ê°„ ì§„ë£Œì¸ ê²½ìš° í˜•í‰ì„± ì ìš©
        if schedule.has_night_shift:
            assignable_for_night = self.fairness_analyzer.get_assignable_employees_for_night_shift(self.year)
            # ì•¼ê°„ ë°°ì • ê°€ëŠ¥í•œ ì§ì› ì¤‘ì—ì„œ ìš°ì„  ë°°ì¹˜
            priority_employees = [
                emp_id for emp_id in available_employees
                if emp_id in assignable_for_night
            ]
            
            if len(priority_employees) >= required_staff:
                # ìš°ì„ ìˆœìœ„ ì§ì›ë§Œìœ¼ë¡œ ì¶©ë¶„
                return self.select_employees(priority_employees, required_staff)
            else:
                # ìš°ì„ ìˆœìœ„ ì§ì› + ë‚˜ë¨¸ì§€ ì§ì›
                selected = priority_employees.copy()
                remaining_needed = required_staff - len(selected)
                other_employees = [
                    emp_id for emp_id in available_employees
                    if emp_id not in priority_employees
                ]
                selected.extend(self.select_employees(other_employees, remaining_needed))
                return selected
        
        # ì£¼ë§ì¸ ê²½ìš°
        elif schedule_date.weekday() in [5, 6]:  # í† , ì¼
            assignable_for_weekend = [
                emp_id for emp_id, data in 
                self.fairness_analyzer.get_weekend_work_fairness(self.year)['employees'].items()
                if data['can_assign']
            ]
            
            priority_employees = [
                emp_id for emp_id in available_employees
                if emp_id in assignable_for_weekend
            ]
            
            if len(priority_employees) >= required_staff:
                return self.select_employees(priority_employees, required_staff)
            else:
                selected = priority_employees.copy()
                remaining_needed = required_staff - len(selected)
                other_employees = [
                    emp_id for emp_id in available_employees
                    if emp_id not in priority_employees
                ]
                selected.extend(self.select_employees(other_employees, remaining_needed))
                return selected
        
        # ì¼ë°˜ ê·¼ë¬´ì¼
        else:
            return self.select_employees(available_employees, required_staff)
    
    def select_employees(self, employee_ids, count):
        """ì§ì› ì„ íƒ (ì¶”ê°€ ë¡œì§ ì ìš© ê°€ëŠ¥)"""
        import random
        if len(employee_ids) <= count:
            return employee_ids
        return random.sample(employee_ids, count)
    
    def get_unavailable_employees(self, date_obj):
        """í•´ë‹¹ ë‚ ì§œì— ë°°ì¹˜ ë¶ˆê°€ëŠ¥í•œ ì§ì› ëª©ë¡"""
        leaves = LeaveRecord.query.filter_by(
            leave_date=date_obj
        ).all()
        
        return [leave.employee_id for leave in leaves]
```

**UI í‘œì‹œ**:
```python
def render_fairness_dashboard(year):
    """í˜•í‰ì„± ëŒ€ì‹œë³´ë“œ ë Œë”ë§"""
    analyzer = YearlyFairnessAnalysis()
    report = analyzer.get_comprehensive_fairness_report(year)
    
    html = f"""
    <div class="fairness-dashboard">
        <h2>{year}ë…„ í˜•í‰ì„± ë¶„ì„</h2>
        
        <div class="section">
            <h3>ì•¼ê°„ ê·¼ë¬´ í˜„í™©</h3>
            <p>ìµœëŒ€ íšŸìˆ˜: {report['night_shift']['max_count']}íšŒ</p>
            <table>
                <thead>
                    <tr>
                        <th>ì§ì›ëª…</th>
                        <th>ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜</th>
                        <th>ìƒíƒœ</th>
                    </tr>
                </thead>
                <tbody>
    """
    
    for emp_id, data in report['night_shift']['employees'].items():
        status_icon = 'âœ…' if data['is_maxed'] else 'ğŸ“Š'
        status_text = 'ìµœëŒ€ ë„ë‹¬' if data['is_maxed'] else f"{report['night_shift']['max_count'] - data['count']}íšŒ ë‚¨ìŒ"
        
        html += f"""
                    <tr class="{'maxed' if data['is_maxed'] else 'assignable'}">
                        <td>{data['name']}</td>
                        <td>{data['count']}íšŒ</td>
                        <td>{status_icon} {status_text}</td>
                    </tr>
        """
    
    html += """
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <h3>ì£¼ë§ ê·¼ë¬´ í˜„í™©</h3>
            <p>ìµœëŒ€ íšŸìˆ˜: """ + str(report['weekend_work']['max_count']) + """íšŒ</p>
            <table>
                <thead>
                    <tr>
                        <th>ì§ì›ëª…</th>
                        <th>ì£¼ë§ ê·¼ë¬´ íšŸìˆ˜</th>
                        <th>ìƒíƒœ</th>
                    </tr>
                </thead>
                <tbody>
    """
    
    for emp_id, data in report['weekend_work']['employees'].items():
        status_icon = 'âœ…' if data['is_maxed'] else 'ğŸ“Š'
        status_text = 'ìµœëŒ€ ë„ë‹¬' if data['is_maxed'] else f"{report['weekend_work']['max_count'] - data['count']}íšŒ ë‚¨ìŒ"
        
        html += f"""
                    <tr class="{'maxed' if data['is_maxed'] else 'assignable'}">
                        <td>{data['name']}</td>
                        <td>{data['count']}íšŒ</td>
                        <td>{status_icon} {status_text}</td>
                    </tr>
        """
    
    html += """
                </tbody>
            </table>
        </div>
        
        <div class="section recommendations">
            <h3>ğŸ’¡ ê¶Œì¥ ì‚¬í•­</h3>
            <ul>
    """
    
    for rec in report['recommendations']:
        priority_class = f"priority-{rec['priority']}"
        html += f"""
                <li class="{priority_class}">
                    {rec['message']}
                </li>
        """
    
    html += """
            </ul>
        </div>
    </div>
    """
    
    return html
```

---

## 8. ì¹´ì¹´ì˜¤í†¡ ì—°ë™ ê´€ë ¨

### 8.1 ì¹´ì¹´ì˜¤í†¡ API ì‚¬ìš© ì‹œ ì£¼ì˜ì‚¬í•­

**ì¶”ê°€ ë‚´ìš©**:
- ì¹´ì¹´ì˜¤ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì • ë° ì‚¬ì—…ììš© API í•„ìš”
- ì¶”ê°€ ê°œë°œ ê¸°ê°„ ë° ë¹„ìš© ë°œìƒ
- ë‹¨ê³„ì  ê°œë°œ ê¶Œì¥

**êµ¬í˜„ ê°€ì´ë“œ**:
```python
# config.py
class KakaoConfig:
    """ì¹´ì¹´ì˜¤í†¡ API ì„¤ì •"""
    
    # ì¹´ì¹´ì˜¤ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì • ì •ë³´
    KAKAO_API_KEY = os.getenv('KAKAO_API_KEY')
    KAKAO_SENDER_KEY = os.getenv('KAKAO_SENDER_KEY')
    KAKAO_TEMPLATE_CODE = os.getenv('KAKAO_TEMPLATE_CODE')
    
    # API ì—”ë“œí¬ì¸íŠ¸
    KAKAO_API_URL = 'https://kapi.kakao.com/v2/api/talk/memo/default/send'
    
    # ë°œì†¡ ì œí•œ
    DAILY_SEND_LIMIT = 1000  # ì¼ì¼ ë°œì†¡ í•œë„
    RATE_LIMIT_PER_SECOND = 10  # ì´ˆë‹¹ ë°œì†¡ í•œë„

class KakaoNotificationService:
    """ì¹´ì¹´ì˜¤í†¡ ì•Œë¦¼ ì„œë¹„ìŠ¤"""
    
    def __init__(self):
        self.api_key = KakaoConfig.KAKAO_API_KEY
        self.sender_key = KakaoConfig.KAKAO_SENDER_KEY
        
        if not self.api_key or not self.sender_key:
            logger.warning("ì¹´ì¹´ì˜¤ API ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤. ì•Œë¦¼ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.")
            self.enabled = False
        else:
            self.enabled = True
    
    def send_leave_application_notification(self, employee, application):
        """ì˜¤í”„/ì—°ì°¨ ì‹ ì²­ ì•Œë¦¼ ë°œì†¡"""
        if not self.enabled:
            logger.info("ì¹´ì¹´ì˜¤ ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
            return False
        
        try:
            # í…œí”Œë¦¿ ë°ì´í„° êµ¬ì„±
            template_data = {
                'employee_name': employee.name,
                'leave_date': application.leave_date.strftime('%Y-%m-%d'),
                'leave_type': application.leave_type,
                'applied_at': application.created_at.strftime('%Y-%m-%d %H:%M')
            }
            
            # ì¹´ì¹´ì˜¤ API í˜¸ì¶œ
            response = self.send_template_message(
                template_code='LEAVE_APPLICATION',
                template_data=template_data,
                recipient_phone=employee.phone_number
            )
            
            if response['success']:
                logger.info(f"ì¹´ì¹´ì˜¤ ì•Œë¦¼ ë°œì†¡ ì„±ê³µ: {employee.name}")
                return True
            else:
                logger.error(f"ì¹´ì¹´ì˜¤ ì•Œë¦¼ ë°œì†¡ ì‹¤íŒ¨: {response['message']}")
                return False
                
        except Exception as e:
            logger.error(f"ì¹´ì¹´ì˜¤ ì•Œë¦¼ ë°œì†¡ ì˜¤ë¥˜: {str(e)}")
            return False
    
    def send_template_message(self, template_code, template_data, recipient_phone):
        """í…œí”Œë¦¿ ë©”ì‹œì§€ ë°œì†¡"""
        headers = {
            'Authorization': f'KakaoAK {self.api_key}',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        data = {
            'template_object': json.dumps({
                'object_type': 'text',
                'text': self.render_template(template_code, template_data),
                'link': {
                    'web_url': 'https://your-domain.com',
                    'mobile_web_url': 'https://your-domain.com'
                }
            }, ensure_ascii=False)
        }
        
        response = requests.post(
            KakaoConfig.KAKAO_API_URL,
            headers=headers,
            data=data
        )
        
        if response.status_code == 200:
            return {'success': True, 'data': response.json()}
        else:
            return {
                'success': False,
                'message': f'HTTP {response.status_code}: {response.text}'
            }
    
    def render_template(self, template_code, template_data):
        """í…œí”Œë¦¿ ë Œë”ë§"""
        templates = {
            'LEAVE_APPLICATION': """
[ì—°ì„¸ë°”ë¡œì¹˜ê³¼ ì•Œë¦¼]

{employee_name}ë‹˜ì´ ì˜¤í”„/ì—°ì°¨ë¥¼ ì‹ ì²­í–ˆìŠµë‹ˆë‹¤.

ë‚ ì§œ: {leave_date}
ì¢…ë¥˜: {leave_type}
ì‹ ì²­ ì‹œê°„: {applied_at}

ê´€ë¦¬ì í˜ì´ì§€ì—ì„œ í™•ì¸í•˜ì„¸ìš”.
            """.strip()
        }
        
        template = templates.get(template_code, '')
        return template.format(**template_data)
```

**ë‹¨ê³„ì  ê°œë°œ ê³„íš**:
```
Phase 1 (ì¦‰ì‹œ ê°€ëŠ¥):
- í”„ë¡œê·¸ë¨ ë‚´ ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„
- ì´ë©”ì¼ ì•Œë¦¼ (ì„ íƒì )

Phase 2 (3-5ì£¼ ì¶”ê°€):
- ì¹´ì¹´ì˜¤ ë¹„ì¦ˆë‹ˆìŠ¤ ê³„ì • ì‹ ì²­
- ì¹´ì¹´ì˜¤ ì±„ë„ ê°œì„¤
- ì‚¬ì—…ììš© API ì‹ ì²­ ë° ìŠ¹ì¸ ëŒ€ê¸°
- í…œí”Œë¦¿ ë“±ë¡ ë° ìŠ¹ì¸

Phase 3 (1-2ì£¼):
- ì¹´ì¹´ì˜¤í†¡ ì•Œë¦¼ ê¸°ëŠ¥ ê°œë°œ
- í…ŒìŠ¤íŠ¸ ë° ì•ˆì •í™”
- ì‹¤ì‚¬ìš© ë°°í¬
```

---

## 9. ê¸°íƒ€ ê°œì„  ì‚¬í•­

### 9.1 ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦

**ì¶”ê°€ ê²€ì¦ ë¡œì§**:
```python
class DataIntegrityValidator:
    """ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦"""
    
    def validate_monthly_schedule(self, year, month):
        """ì›”ê°„ ìŠ¤ì¼€ì¤„ ì „ì²´ ê²€ì¦
        
        Returns:
            {
                'valid': True/False,
                'errors': [...]  # ì˜¤ë¥˜ ëª©ë¡
            }
        """
        errors = []
        
        # 1. í•„ìš” ì¸ì› ì¶©ì¡± ì—¬ë¶€
        schedules = DailySchedule.query.filter(
            extract('year', DailySchedule.schedule_date) == year,
            extract('month', DailySchedule.schedule_date) == month
        ).all()
        
        for schedule in schedules:
            assigned_count = StaffAssignment.query.filter_by(
                schedule_id=schedule.id,
                status='assigned'
            ).count()
            
            if assigned_count < schedule.required_staff:
                errors.append({
                    'type': 'staff_shortage',
                    'date': schedule.schedule_date,
                    'required': schedule.required_staff,
                    'assigned': assigned_count
                })
        
        # 2. ì˜¤í”„ ì¼ìˆ˜ ì¶©ì¡± ì—¬ë¶€
        employees = Employee.query.filter_by(is_active=True).all()
        
        for emp in employees:
            off_count = LeaveRecord.query.filter(
                LeaveRecord.employee_id == emp.id,
                extract('year', LeaveRecord.leave_date) == year,
                extract('month', LeaveRecord.leave_date) == month,
                LeaveRecord.leave_type == 'ì˜¤í”„'
            ).count()
            
            if off_count != 8:
                errors.append({
                    'type': 'off_count_mismatch',
                    'employee_id': emp.id,
                    'employee_name': emp.name,
                    'required': 8,
                    'actual': off_count
                })
        
        # 3. ì—°ì† ê·¼ë¬´ ì œí•œ í™•ì¸ (4ì¼)
        for emp in employees:
            consecutive_work = self.check_consecutive_work_days(emp.id, year, month)
            
            if consecutive_work > 4:
                errors.append({
                    'type': 'consecutive_work_limit',
                    'employee_id': emp.id,
                    'employee_name': emp.name,
                    'consecutive_days': consecutive_work
                })
        
        return {
            'valid': len(errors) == 0,
            'error_count': len(errors),
            'errors': errors
        }
    
    def check_consecutive_work_days(self, employee_id, year, month):
        """ì—°ì† ê·¼ë¬´ì¼ í™•ì¸"""
        assignments = StaffAssignment.query.join(DailySchedule).filter(
            StaffAssignment.employee_id == employee_id,
            extract('year', DailySchedule.schedule_date) == year,
            extract('month', DailySchedule.schedule_date) == month,
            StaffAssignment.status == 'assigned'
        ).order_by(DailySchedule.schedule_date).all()
        
        if not assignments:
            return 0
        
        max_consecutive = 1
        current_consecutive = 1
        prev_date = assignments[0].schedule.schedule_date
        
        for assignment in assignments[1:]:
            current_date = assignment.schedule.schedule_date
            
            if (current_date - prev_date).days == 1:
                current_consecutive += 1
                max_consecutive = max(max_consecutive, current_consecutive)
            else:
                current_consecutive = 1
            
            prev_date = current_date
        
        return max_consecutive
```

---

## 10. ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ

### 10.1 ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜

**ê¸°ì¡´ ì‹œìŠ¤í…œì—ì„œ ìƒˆ ì‹œìŠ¤í…œìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜**:

```python
class SystemMigration:
    """ì‹œìŠ¤í…œ ë§ˆì´ê·¸ë ˆì´ì…˜"""
    
    def migrate_employee_work_type(self):
        """ì§ì› ê·¼ë¬´ í˜•íƒœ ë§ˆì´ê·¸ë ˆì´ì…˜
        
        ëª¨ë“  ì§ì›ì„ ì£¼4ì¼ë¡œ í†µì¼
        """
        employees = Employee.query.all()
        
        for emp in employees:
            # ê¸°ì¡´ work_type í•„ë“œê°€ ìˆë‹¤ë©´
            if hasattr(emp, 'work_type'):
                emp.work_type = 'ì£¼4ì¼'
        
        db.session.commit()
        logger.info(f"ì§ì› ê·¼ë¬´ í˜•íƒœ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ: {len(employees)}ëª…")
    
    def migrate_leave_records(self):
        """íœ´ê°€ ê¸°ë¡ ë§ˆì´ê·¸ë ˆì´ì…˜
        
        ì—°ì°¨ë¥¼ ì˜¤í”„ë¡œ ë³€í™˜
        """
        annual_leaves = LeaveRecord.query.filter_by(leave_type='ì—°ì°¨').all()
        
        for leave in annual_leaves:
            leave.leave_type = 'ì˜¤í”„'
        
        db.session.commit()
        logger.info(f"íœ´ê°€ ê¸°ë¡ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ: {len(annual_leaves)}ê±´")
    
    def add_birth_date_to_employees(self):
        """ì§ì› í…Œì´ë¸”ì— ìƒë…„ì›”ì¼ ì¶”ê°€"""
        # ALTER TABLE employees ADD COLUMN birth_date DATE;
        
        logger.info("ìƒë…„ì›”ì¼ ì»¬ëŸ¼ ì¶”ê°€ ì™„ë£Œ. ê° ì§ì›ì˜ ìƒë…„ì›”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    
    def run_full_migration(self):
        """ì „ì²´ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰"""
        try:
            logger.info("ì‹œìŠ¤í…œ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘...")
            
            # 1. ë°±ì—…
            self.backup_database()
            
            # 2. ìŠ¤í‚¤ë§ˆ ë³€ê²½
            self.add_birth_date_to_employees()
            
            # 3. ë°ì´í„° ë³€í™˜
            self.migrate_employee_work_type()
            self.migrate_leave_records()
            
            # 4. ê²€ì¦
            validation = DataIntegrityValidator()
            result = validation.validate_all_data()
            
            if result['valid']:
                logger.info("ë§ˆì´ê·¸ë ˆì´ì…˜ ì„±ê³µ!")
                return True
            else:
                logger.error(f"ë§ˆì´ê·¸ë ˆì´ì…˜ ê²€ì¦ ì‹¤íŒ¨: {result['errors']}")
                # ë¡¤ë°± ê³ ë ¤
                return False
                
        except Exception as e:
            logger.error(f"ë§ˆì´ê·¸ë ˆì´ì…˜ ì˜¤ë¥˜: {str(e)}")
            # ë¡¤ë°±
            self.rollback_migration()
            return False
    
    def backup_database(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…"""
        backup_path = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sql"
        # ë°±ì—… ë¡œì§ êµ¬í˜„
        logger.info(f"ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì™„ë£Œ: {backup_path}")
```

---

## ğŸ“Œ ìš”ì•½

### ì£¼ìš” ë³€ê²½ ì‚¬í•­
1. **ê·¼ë¬´ ì‹œìŠ¤í…œ**: ì£¼4ì¼ ê¸°ë³¸, ì§ì›ë³„ ì£¼5ì¼ ì„¤ì • ê°€ëŠ¥ (ì˜¤í”„/ì—°ì°¨ ìë™ ê³„ì‚°)
2. **ì›ì¥ íŒ¨í„´ í™•ì¥**: ìš”ì¼ë³„ + ì£¼ë³„ íŒ¨í„´ ì§€ì›
3. **ë°°ì¹˜ ì‹œìŠ¤í…œ**: ì£¼ì°¨ë³„ ì„ íƒ ë°°ì¹˜, í™•ì • ì£¼ì°¨ ë³´í˜¸
4. **ë³´ì•ˆ ê°•í™”**: ìƒë…„ì›”ì¼ ì¸ì¦ ì¶”ê°€
5. **UI ê°œì„ **: ì•¼ê°„ ì§„ë£Œ í‘œì‹œ, ì£¼ê°„ ì˜¤í”„ í˜„í™© ì‚­ì œ
6. **ì£¼ì°¨ ê¸°ì¤€**: ì¼~í†  ê¸°ì¤€ìœ¼ë¡œ ë³€ê²½
7. **í†µê³„**: ì›”ë³„ ê¸°ì¤€, **í˜•í‰ì„±ì€ ì—°ë‹¨ìœ„ ëˆ„ì  ëª©í‘œ ê¸°ë°˜**
8. **ì¹´ì¹´ì˜¤í†¡ ì—°ë™**: ë‹¨ê³„ì  ê°œë°œ ê³„íš

### í˜•í‰ì„± ê´€ë¦¬ í•µì‹¬ â­
- **ì—°ë‹¨ìœ„ + ëˆ„ì  ëª©í‘œ ê¸°ë°˜**: ì‹¤ì œ ìŠ¤ì¼€ì¤„ì„ ê¸°ë°˜ìœ¼ë¡œ ì›”ë³„ ëˆ„ì  ëª©í‘œ ìë™ ê³„ì‚°
- **ì˜ˆì‹œ**:
  - 1ì›”~6ì›”: ì•¼ê°„ 50ì¼, í•„ìš” 700ì¸-ì¼ â†’ ëª©í‘œ 35íšŒ/ì¸
  - A: 30íšŒ (ë¶€ì¡± 5íšŒ) â†’ ìš°ì„  ë°°ì • âœ…
  - E: 40íšŒ (ì´ˆê³¼ 5íšŒ) â†’ ë°°ì • ìì œ âš ï¸
- **ìë™ ë°°ì¹˜**: ëª©í‘œ ëŒ€ë¹„ ë¶€ì¡±í•œ ì§ì› ìš°ì„  ì„ íƒ
- **ì‹¤ì‹œê°„ ì¡°ì •**: ë§¤ì›” ëª©í‘œê°€ ê°±ì‹ ë˜ì–´ ìì—°ìŠ¤ëŸ½ê²Œ í˜•í‰ì„± ë‹¬ì„±

### ê°œë°œ ìš°ì„ ìˆœìœ„
1. **Phase 1 (í•„ìˆ˜)**: ê·¼ë¬´ ì‹œìŠ¤í…œ ë³€ê²½, ë°°ì¹˜ ì‹œìŠ¤í…œ ê°œì„ , ëˆ„ì  ëª©í‘œ ê¸°ë°˜ í˜•í‰ì„± ë¡œì§
2. **Phase 2 (ì¤‘ìš”)**: ë³´ì•ˆ ê°•í™”, UI ê°œì„ , í˜•í‰ì„± ëŒ€ì‹œë³´ë“œ
3. **Phase 3 (ì„ íƒ)**: ì¹´ì¹´ì˜¤í†¡ ì—°ë™

---

**ë¬¸ì„œ ë²„ì „**: 1.0  
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025ë…„ 10ì›” 22ì¼
