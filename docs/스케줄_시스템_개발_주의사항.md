# ì—°ì„¸ë°”ë¡œì¹˜ê³¼ ìŠ¤ì¼€ì¤„ ì‹œìŠ¤í…œ ê°œë°œ ì£¼ì˜ì‚¬í•­

**ì‘ì„±ì¼**: 2025ë…„ 10ì›” 22ì¼  
**ëª©ì **: ê°œë°œ ì‹œ í•µì‹¬ ë¡œì§ ë° ê³„ì‚° ë°©ë²• ì •ë¦¬  
**ëŒ€ìƒ**: ê°œë°œì

---

## ğŸ“‘ ëª©ì°¨

1. [í•µì‹¬ ê°œë…](#1-í•µì‹¬-ê°œë…)
2. [ì£¼ ë‹¨ìœ„ ê´€ë¦¬](#2-ì£¼-ë‹¨ìœ„-ê´€ë¦¬)
3. [ìë¦¬ ê³„ì‚° ë¡œì§](#3-ìë¦¬-ê³„ì‚°-ë¡œì§)
4. [ì›” ê²½ê³„ ì²˜ë¦¬](#4-ì›”-ê²½ê³„-ì²˜ë¦¬)
5. [ì˜¤í”„/ì—°ì°¨ ë°°ì • ë¡œì§](#5-ì˜¤í”„ì—°ì°¨-ë°°ì •-ë¡œì§)
6. [ê²€ì¦ ê·œì¹™](#6-ê²€ì¦-ê·œì¹™)
7. [í•¨ìˆ˜ êµ¬í˜„ ì˜ˆì‹œ](#7-í•¨ìˆ˜-êµ¬í˜„-ì˜ˆì‹œ)
8. [ì£¼ì˜ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸](#8-ì£¼ì˜ì‚¬í•­-ì²´í¬ë¦¬ìŠ¤íŠ¸)

---

# 1. í•µì‹¬ ê°œë…

## 1.1 ê¸°ë³¸ ìƒìˆ˜

```python
# ê³ ì • ìƒìˆ˜
TOTAL_STAFF = 20          # ì „ì²´ ì§ì› ìˆ˜
WORK_DAYS_PER_WEEK = 4    # ì£¼ë‹¹ ê·¼ë¬´ì¼
OFF_DAYS_PER_WEEK = 2     # ì£¼ë‹¹ ì˜¤í”„ì¼
DAYS_IN_WEEK = 6          # í•œ ì£¼ (ì›”~í† )

# ë“±ê¸‰ë³„ ì¸ì›
TEAM_LEADER = 1           # íŒ€ì¥
SENIOR = 4                # ê³ ë…„ì°¨
MID = 5                   # ì¤‘ë…„ì°¨
JUNIOR = 4                # ì €ë…„ì°¨

# ìš”ì¼ ìƒìˆ˜
WEEKDAYS = ["ì›”", "í™”", "ìˆ˜", "ëª©", "ê¸ˆ", "í† ", "ì¼"]
SUNDAY = 6                # ì¼ìš”ì¼ ì¸ë±ìŠ¤
```

---

## 1.2 í•µì‹¬ ì›ì¹™

```
âœ… ì£¼ ë‹¨ìœ„ ê´€ë¦¬: ì›”~í†  6ì¼ì„ 1ì£¼ë¡œ ê´€ë¦¬
âœ… ì¼ìš”ì¼ ì²˜ë¦¬: ì „ì› íœ´ë¬´, ìë¦¬ ê³„ì‚°ì—ì„œ ì œì™¸
âœ… ì´ ì¸ì› ë³´ì¡´: ë°°ì¹˜ + ì˜¤í”„ + ì—°ì°¨ = 20ëª… (í•­ìƒ!)
âœ… ì£¼ì°¨ ê²½ê³„: ì´ì „/ë‹¤ìŒ ë‹¬ í¬í•¨í•˜ì—¬ ì™„ì „í•œ ì£¼ ë‹¨ìœ„
```

---

# 2. ì£¼ ë‹¨ìœ„ ê´€ë¦¬

## 2.1 ì£¼ì°¨ ì •ì˜

```python
def get_week_range(date):
    """
    ì£¼ì–´ì§„ ë‚ ì§œê°€ ì†í•œ ì£¼ì˜ ì‹œì‘(ì›”)ê³¼ ë(í† ) ë°˜í™˜
    
    Args:
        date: datetime ê°ì²´
        
    Returns:
        (week_start, week_end): ì›”ìš”ì¼ê³¼ í† ìš”ì¼ ë‚ ì§œ
        
    ì£¼ì˜ì‚¬í•­:
        - ì¼ìš”ì¼ì€ ì´ì „ ì£¼ì˜ ë§ˆì§€ë§‰ìœ¼ë¡œ ê°„ì£¼í•˜ì§€ ì•ŠìŒ
        - ì¼ìš”ì¼ì´ ì…ë ¥ë˜ë©´ ë‹¤ìŒ ì›”ìš”ì¼ë¶€í„° ì‹œì‘í•˜ëŠ” ì£¼ ë°˜í™˜
    """
    weekday = date.weekday()  # 0=ì›”ìš”ì¼, 6=ì¼ìš”ì¼
    
    if weekday == 6:  # ì¼ìš”ì¼
        # ë‹¤ìŒ ì›”ìš”ì¼ë¶€í„° ì‹œì‘
        week_start = date + timedelta(days=1)
    else:
        # ì´ë²ˆ ì£¼ ì›”ìš”ì¼
        week_start = date - timedelta(days=weekday)
    
    # í† ìš”ì¼ê¹Œì§€
    week_end = week_start + timedelta(days=5)
    
    return week_start, week_end


# ì˜ˆì‹œ
date_example = datetime(2025, 1, 3)  # ê¸ˆìš”ì¼
week_start, week_end = get_week_range(date_example)
# ê²°ê³¼: 2024-12-30 (ì›”) ~ 2025-01-04 (í† )
```

---

## 2.2 ì›”ì˜ ì£¼ì°¨ ê³„ì‚°

```python
def get_month_weeks(year, month):
    """
    í•´ë‹¹ ì›”ì˜ ëª¨ë“  ì£¼ì°¨ ê³„ì‚° (ì´ì „/ë‹¤ìŒ ë‹¬ í¬í•¨)
    
    Args:
        year: ë…„ë„
        month: ì›”
        
    Returns:
        list of (week_start, week_end, week_number)
        
    ì£¼ì˜ì‚¬í•­:
        - í•´ë‹¹ ì›”ì˜ ì²«ë‚ ì´ ì†í•œ ì£¼ë¶€í„° ì‹œì‘
        - í•´ë‹¹ ì›”ì˜ ë§ˆì§€ë§‰ë‚ ì´ ì†í•œ ì£¼ê¹Œì§€ í¬í•¨
        - ì£¼ì°¨ ë²ˆí˜¸ëŠ” 1ë¶€í„° ì‹œì‘
    """
    # í•´ë‹¹ ì›”ì˜ ì²«ë‚ ê³¼ ë§ˆì§€ë§‰ë‚ 
    first_day = datetime(year, month, 1)
    
    if month == 12:
        last_day = datetime(year + 1, 1, 1) - timedelta(days=1)
    else:
        last_day = datetime(year, month + 1, 1) - timedelta(days=1)
    
    # ì²«ë‚ ì´ ì†í•œ ì£¼ì˜ ì‹œì‘
    week_start, _ = get_week_range(first_day)
    
    # ë§ˆì§€ë§‰ë‚ ì´ ì†í•œ ì£¼ì˜ ë
    _, week_end_target = get_week_range(last_day)
    
    weeks = []
    week_number = 1
    current_start = week_start
    
    while current_start <= week_end_target:
        current_end = current_start + timedelta(days=5)  # í† ìš”ì¼
        weeks.append((current_start, current_end, week_number))
        
        current_start = current_end + timedelta(days=2)  # ë‹¤ìŒ ì›”ìš”ì¼ (ì¼ìš”ì¼ ê±´ë„ˆëœ€)
        week_number += 1
    
    return weeks


# ì˜ˆì‹œ: 2025ë…„ 1ì›”
weeks = get_month_weeks(2025, 1)
# ê²°ê³¼:
# 1ì£¼ì°¨: 2024-12-30 ~ 2025-01-04
# 2ì£¼ì°¨: 2025-01-06 ~ 2025-01-11
# 3ì£¼ì°¨: 2025-01-13 ~ 2025-01-18
# 4ì£¼ì°¨: 2025-01-20 ~ 2025-01-25
# 5ì£¼ì°¨: 2025-01-27 ~ 2025-02-01
```

---

# 3. ìë¦¬ ê³„ì‚° ë¡œì§

## 3.1 ë‚ ì§œë³„ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬

```python
def calculate_available_slots(date, doctor_schedule):
    """
    íŠ¹ì • ë‚ ì§œì˜ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬ ê³„ì‚°
    
    Args:
        date: datetime ê°ì²´
        doctor_schedule: ì›ì¥ ìŠ¤ì¼€ì¤„ ì •ë³´
        
    Returns:
        int: íœ´ë¬´ ê°€ëŠ¥ ì¸ì› ìˆ˜
        
    ê³µì‹:
        íœ´ë¬´ ê°€ëŠ¥ = ì´ ì§ì›(20) - í•„ìš” ë°°ì¹˜ ì¸ì›
        
    ì£¼ì˜ì‚¬í•­:
        - ì¼ìš”ì¼ì€ 0 ë°˜í™˜ (ì „ì› íœ´ë¬´ë¡œ ê³„ì‚° ì•ˆí•¨)
        - í† ìš”ì¼ì€ ë³´í†µ 6ëª… ë°°ì¹˜ â†’ 14ìë¦¬
        - í‰ì¼ì€ ë³´í†µ 14ëª… ë°°ì¹˜ â†’ 6ìë¦¬
    """
    weekday = date.weekday()
    
    # ì¼ìš”ì¼ì€ ì „ì› íœ´ë¬´
    if weekday == 6:
        return 0
    
    # ì›ì¥ ì¡°í•©ì— ë”°ë¥¸ í•„ìš” ì¸ì› ê³„ì‚°
    required_staff = get_required_staff(doctor_schedule)
    
    # íœ´ë¬´ ê°€ëŠ¥ ìë¦¬
    available_slots = TOTAL_STAFF - required_staff
    
    return available_slots


def get_required_staff(doctor_schedule):
    """
    ì›ì¥ ì¡°í•©ì— ë”°ë¥¸ í•„ìš” ì§ì› ìˆ˜ ê³„ì‚°
    
    Args:
        doctor_schedule: dict
            {
                'doctors': ['ë°•ì°½ë²”', 'êµ¬ìœ¤ì§„', 'ìœ¤ì•„í–¥'],
                'night_shift': True  # ì•¼ê°„ ì§„ë£Œ ì—¬ë¶€
            }
            
    Returns:
        int: í•„ìš”í•œ ì§ì› ìˆ˜
        
    ê·œì¹™:
        - ì›ì¥ 3ëª… + ì•¼ê°„: íŒ€ì¥1 + ê³ 4 + ì¤‘5 + ì €4 = 14ëª…
        - ì›ì¥ 2ëª… (í† ìš”ì¼): íŒ€ì¥1 + ê³ 2 + ì¤‘2 + ì €1 = 6ëª…
        - ì›ì¥ ì¡°í•© ë³€ê²½ ì‹œ ì´ í•¨ìˆ˜ë§Œ ìˆ˜ì •
    """
    doctor_count = len(doctor_schedule['doctors'])
    is_night = doctor_schedule.get('night_shift', False)
    
    if doctor_count == 3 and is_night:
        return 14  # í‰ì¼ í’€íƒ€ì„
    elif doctor_count == 2:
        return 6   # í† ìš”ì¼
    else:
        # ê¸°íƒ€ ì¡°í•©ì— ëŒ€í•œ ê·œì¹™ ì¶”ê°€
        return 14  # ê¸°ë³¸ê°’


# ì˜ˆì‹œ
doctor_schedule_weekday = {
    'doctors': ['ë°•ì°½ë²”', 'êµ¬ìœ¤ì§„', 'ìœ¤ì•„í–¥'],
    'night_shift': True
}
slots_weekday = calculate_available_slots(
    datetime(2025, 1, 6),  # ì›”ìš”ì¼
    doctor_schedule_weekday
)
# ê²°ê³¼: 20 - 14 = 6ìë¦¬

doctor_schedule_saturday = {
    'doctors': ['ë°•ì°½ë²”', 'êµ¬ìœ¤ì§„'],
    'night_shift': False
}
slots_saturday = calculate_available_slots(
    datetime(2025, 1, 4),  # í† ìš”ì¼
    doctor_schedule_saturday
)
# ê²°ê³¼: 20 - 6 = 14ìë¦¬
```

---

## 3.2 ì£¼ì°¨ë³„ ìë¦¬ ê³„ì‚°

```python
def calculate_week_slots(week_start, week_end, doctor_schedules):
    """
    ì£¼ì°¨ë³„ ì´ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬ ê³„ì‚°
    
    Args:
        week_start: ì£¼ ì‹œì‘ì¼ (ì›”ìš”ì¼)
        week_end: ì£¼ ì¢…ë£Œì¼ (í† ìš”ì¼)
        doctor_schedules: dict {date: schedule}
        
    Returns:
        dict: {
            'total_slots': int,      # ì´ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬
            'off_target': int,       # ì˜¤í”„ ë°°ì • ëª©í‘œ
            'annual_available': int, # ì—°ì°¨ ê°€ëŠ¥ ìë¦¬
            'has_holiday': bool,     # íœ´ë¬´ì¼ í¬í•¨ ì—¬ë¶€
            'daily_slots': dict      # ë‚ ì§œë³„ ìë¦¬ ìˆ˜
        }
        
    ì£¼ì˜ì‚¬í•­:
        - ì¼ìš”ì¼ì´ ì£¼ ì¤‘ê°„ì— ìˆìœ¼ë©´ has_holiday = True
        - íœ´ë¬´ì¼ì´ ìˆìœ¼ë©´ ì˜¤í”„ ëª©í‘œê°€ 20ìë¦¬ë¡œ ê°ì†Œ
    """
    result = {
        'total_slots': 0,
        'off_target': 0,
        'annual_available': 0,
        'has_holiday': False,
        'daily_slots': {}
    }
    
    current_date = week_start
    
    while current_date <= week_end:
        weekday = current_date.weekday()
        
        # ì¼ìš”ì¼ ì²´í¬
        if weekday == 6:
            result['has_holiday'] = True
            current_date += timedelta(days=1)
            continue
        
        # ë‚ ì§œë³„ ìë¦¬ ê³„ì‚°
        schedule = doctor_schedules.get(current_date)
        slots = calculate_available_slots(current_date, schedule)
        
        result['daily_slots'][current_date] = slots
        result['total_slots'] += slots
        
        current_date += timedelta(days=1)
    
    # ì˜¤í”„ ëª©í‘œ ê³„ì‚°
    if result['has_holiday']:
        # ì¼ìš”ì¼ í¬í•¨: ì£¼ 1ì¼ë§Œ ì˜¤í”„ í•„ìš”
        result['off_target'] = TOTAL_STAFF * 1  # 20ìë¦¬
    else:
        # ì •ìƒ ì£¼: ì£¼ 2ì¼ ì˜¤í”„ í•„ìš”
        result['off_target'] = TOTAL_STAFF * 2  # 40ìë¦¬
    
    # ì—°ì°¨ ê°€ëŠ¥ ìë¦¬
    result['annual_available'] = result['total_slots'] - result['off_target']
    
    # ìŒìˆ˜ ë°©ì§€ (ìë¦¬ê°€ ë¶€ì¡±í•œ ê²½ìš°)
    if result['annual_available'] < 0:
        result['annual_available'] = 0
    
    return result


# ì˜ˆì‹œ: 1ì£¼ì°¨ (2024-12-30 ~ 2025-01-04, 1/1 íœ´ë¬´)
week_slots = calculate_week_slots(
    datetime(2024, 12, 30),
    datetime(2025, 1, 4),
    doctor_schedules
)
# ê²°ê³¼:
# {
#     'total_slots': 38,       # 6+6+0+6+6+14
#     'off_target': 20,        # íœ´ë¬´ì¼ í¬í•¨ ì£¼
#     'annual_available': 18,  # 38 - 20
#     'has_holiday': True,
#     'daily_slots': {...}
# }
```

---

## 3.3 ì›”ê°„ ìë¦¬ ê³„ì‚°

```python
def calculate_month_slots(year, month, doctor_schedules):
    """
    ì›”ê°„ ì´ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬ ê³„ì‚°
    
    Args:
        year: ë…„ë„
        month: ì›”
        doctor_schedules: dict {date: schedule}
        
    Returns:
        dict: {
            'weeks': list,           # ì£¼ì°¨ë³„ ì •ë³´
            'total_slots': int,      # ì´ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬
            'total_off': int,        # ì´ ì˜¤í”„ ëª©í‘œ
            'total_annual': int,     # ì´ ì—°ì°¨ ê°€ëŠ¥
            'week_count': int        # ì£¼ ê°œìˆ˜
        }
    """
    weeks = get_month_weeks(year, month)
    
    result = {
        'weeks': [],
        'total_slots': 0,
        'total_off': 0,
        'total_annual': 0,
        'week_count': len(weeks)
    }
    
    for week_start, week_end, week_number in weeks:
        week_data = calculate_week_slots(week_start, week_end, doctor_schedules)
        
        week_info = {
            'week_number': week_number,
            'week_start': week_start,
            'week_end': week_end,
            **week_data
        }
        
        result['weeks'].append(week_info)
        result['total_slots'] += week_data['total_slots']
        result['total_off'] += week_data['off_target']
        result['total_annual'] += week_data['annual_available']
    
    return result


# ì˜ˆì‹œ: 2025ë…„ 1ì›”
month_slots = calculate_month_slots(2025, 1, doctor_schedules)
# ê²°ê³¼:
# {
#     'total_slots': 215,
#     'total_off': 180,      # 20+40+40+40+40
#     'total_annual': 35,    # 18+4+4+4+5
#     'week_count': 5
# }
```

---

# 4. ì›” ê²½ê³„ ì²˜ë¦¬

## 4.1 ì´ì „ ë‹¬ ë°°ì • ê°€ì ¸ì˜¤ê¸°

```python
def get_previous_month_carryover(year, month):
    """
    ì´ì „ ë‹¬ì—ì„œ ì´ì›”ëœ ì£¼ì°¨ ë°°ì • ê°€ì ¸ì˜¤ê¸°
    
    Args:
        year: í˜„ì¬ ì›”ì˜ ë…„ë„
        month: í˜„ì¬ ì›”
        
    Returns:
        dict: {
            'week_start': datetime,
            'week_end': datetime,
            'assignments': dict  # ë‚ ì§œë³„ ë°°ì¹˜ ì •ë³´
        }
        None if ì´ì›” ì—†ìŒ
        
    ì£¼ì˜ì‚¬í•­:
        - í˜„ì¬ ì›”ì˜ ì²«ë‚ ì´ ì†í•œ ì£¼ì˜ ì‹œì‘ì´
          ì´ì „ ë‹¬ì— ìˆë‹¤ë©´ í•´ë‹¹ ì£¼ ì „ì²´ë¥¼ ê°€ì ¸ì˜´
        - ì´ë¯¸ ë°°ì •ëœ ë‚´ìš©ì€ ìˆ˜ì • ë¶ˆê°€ë¡œ í‘œì‹œ
    """
    first_day = datetime(year, month, 1)
    week_start, week_end = get_week_range(first_day)
    
    # ì£¼ ì‹œì‘ì´ ì´ì „ ë‹¬ì¸ ê²½ìš°
    if week_start.month != month or week_start.year != year:
        # DBì—ì„œ í•´ë‹¹ ì£¼ì˜ ë°°ì • ë‚´ìš© ê°€ì ¸ì˜¤ê¸°
        carryover = load_week_assignment(week_start, week_end)
        
        if carryover:
            return {
                'week_start': week_start,
                'week_end': week_end,
                'assignments': carryover,
                'is_locked': True  # ìˆ˜ì • ë¶ˆê°€
            }
    
    return None


# ì‚¬ìš© ì˜ˆì‹œ
carryover = get_previous_month_carryover(2025, 2)
if carryover:
    print(f"1ì£¼ì°¨ëŠ” ì´ë¯¸ ë°°ì •ë¨: {carryover['week_start']} ~ {carryover['week_end']}")
    # ê²°ê³¼: 1ì£¼ì°¨ëŠ” ì´ë¯¸ ë°°ì •ë¨: 2025-01-27 ~ 2025-02-01
```

---

## 4.2 ë‹¤ìŒ ë‹¬ ì£¼ì°¨ í¬í•¨

```python
def include_next_month_week(year, month):
    """
    í˜„ì¬ ì›” ë°°ì • ì‹œ ë‹¤ìŒ ë‹¬ ì²« ì£¼ê¹Œì§€ í¬í•¨í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸
    
    Args:
        year: í˜„ì¬ ì›”ì˜ ë…„ë„
        month: í˜„ì¬ ì›”
        
    Returns:
        dict: {
            'include': bool,
            'week_start': datetime,
            'week_end': datetime
        }
        
    ì£¼ì˜ì‚¬í•­:
        - í˜„ì¬ ì›”ì˜ ë§ˆì§€ë§‰ë‚ ì´ ì†í•œ ì£¼ê°€
          ë‹¤ìŒ ë‹¬ê¹Œì§€ ê±¸ì³ìˆìœ¼ë©´ True
    """
    # í˜„ì¬ ì›”ì˜ ë§ˆì§€ë§‰ë‚ 
    if month == 12:
        last_day = datetime(year, 12, 31)
        next_month_first = datetime(year + 1, 1, 1)
    else:
        next_month_first = datetime(year, month + 1, 1)
        last_day = next_month_first - timedelta(days=1)
    
    # ë§ˆì§€ë§‰ë‚ ì´ ì†í•œ ì£¼
    week_start, week_end = get_week_range(last_day)
    
    # ì£¼ ëì´ ë‹¤ìŒ ë‹¬ì¸ ê²½ìš°
    if week_end >= next_month_first:
        return {
            'include': True,
            'week_start': week_start,
            'week_end': week_end,
            'next_month_days': (week_end - next_month_first).days + 1
        }
    
    return {
        'include': False
    }


# ì‚¬ìš© ì˜ˆì‹œ
next_week = include_next_month_week(2025, 1)
if next_week['include']:
    print(f"ë‹¤ìŒ ë‹¬ {next_week['next_month_days']}ì¼ í¬í•¨í•˜ì—¬ ë°°ì •")
    # ê²°ê³¼: ë‹¤ìŒ ë‹¬ 1ì¼ í¬í•¨í•˜ì—¬ ë°°ì • (2/1 í† ìš”ì¼)
```

---

## 4.3 ì›”ê°„ ë°°ì • ë²”ìœ„ ê²°ì •

```python
def get_month_assignment_range(year, month):
    """
    í•´ë‹¹ ì›” ë°°ì • ì‹œ ì „ì²´ ë²”ìœ„ ê²°ì •
    
    Args:
        year: ë…„ë„
        month: ì›”
        
    Returns:
        dict: {
            'range_start': datetime,     # ë°°ì • ì‹œì‘ì¼
            'range_end': datetime,       # ë°°ì • ì¢…ë£Œì¼
            'carryover_week': dict,      # ì´ì›”ëœ ì£¼ ì •ë³´
            'new_weeks': list,           # ìƒˆë¡œ ë°°ì •í•  ì£¼ ëª©ë¡
            'next_month_week': dict      # ë‹¤ìŒ ë‹¬ í¬í•¨ ì£¼ ì •ë³´
        }
    """
    # ì´ì „ ë‹¬ ì´ì›” í™•ì¸
    carryover = get_previous_month_carryover(year, month)
    
    # ì´ë²ˆ ë‹¬ ì£¼ì°¨
    weeks = get_month_weeks(year, month)
    
    # ë‹¤ìŒ ë‹¬ í¬í•¨ í™•ì¸
    next_week = include_next_month_week(year, month)
    
    # ìƒˆë¡œ ë°°ì •í•  ì£¼ ê²°ì •
    new_weeks = []
    if carryover:
        # ì²« ì£¼ ì œì™¸í•˜ê³  ë‚˜ë¨¸ì§€ë§Œ
        new_weeks = weeks[1:]
        range_start = weeks[1][0]  # 2ì£¼ì°¨ ì‹œì‘
    else:
        new_weeks = weeks
        range_start = weeks[0][0]  # 1ì£¼ì°¨ ì‹œì‘
    
    range_end = weeks[-1][1]  # ë§ˆì§€ë§‰ ì£¼ ë
    
    return {
        'range_start': range_start,
        'range_end': range_end,
        'carryover_week': carryover,
        'new_weeks': new_weeks,
        'next_month_week': next_week if next_week['include'] else None,
        'total_weeks': len(weeks)
    }


# ì‚¬ìš© ì˜ˆì‹œ
assignment_range = get_month_assignment_range(2025, 2)
print(f"ë°°ì • ë²”ìœ„: {assignment_range['range_start']} ~ {assignment_range['range_end']}")
if assignment_range['carryover_week']:
    print(f"1ì£¼ì°¨ëŠ” ì´ì›”ë¨: ë°°ì • ë¶ˆê°€")
print(f"ìƒˆë¡œ ë°°ì •í•  ì£¼: {len(assignment_range['new_weeks'])}ê°œ")
```

---

# 5. ì˜¤í”„/ì—°ì°¨ ë°°ì • ë¡œì§

## 5.1 ì˜¤í”„ ìë™ ë°°ì •

```python
def auto_assign_off(week_data, staff_list, previous_assignments=None):
    """
    ì£¼ì°¨ë³„ ì˜¤í”„ ìë™ ë°°ì •
    
    Args:
        week_data: ì£¼ì°¨ ì •ë³´ (calculate_week_slots ê²°ê³¼)
        staff_list: ì „ì²´ ì§ì› ë¦¬ìŠ¤íŠ¸
        previous_assignments: ì´ì „ê¹Œì§€ì˜ ë°°ì • ì •ë³´ (í˜•í‰ì„± ê³„ì‚°ìš©)
        
    Returns:
        dict: {
            staff_id: [date1, date2],  # ê° ì§ì›ì˜ ì˜¤í”„ ë‚ ì§œë“¤
            ...
        }
        
    ë¡œì§:
        1. ê° ì§ì›ë§ˆë‹¤ ì£¼ 2ì¼ ë°°ì • (íœ´ë¬´ì¼ í¬í•¨ ì£¼ëŠ” 1ì¼)
        2. ì—¬ìœ ë¡œìš´ ë‚ ì§œ ìš°ì„  ë°°ì •
        3. í˜•í‰ì„± ê³ ë ¤ (ëˆ„ì  ì•¼ê°„, ì£¼ë§ ê·¼ë¬´ ë“±)
        4. ì—°ì† ê·¼ë¬´ 5ì¼ ë°©ì§€
        
    ì£¼ì˜ì‚¬í•­:
        - off_target ë§Œí¼ë§Œ ë°°ì • (ì´ˆê³¼ ê¸ˆì§€)
        - ëª¨ë“  ì§ì›ì´ ê³µí‰í•˜ê²Œ ë°°ì •ë°›ì•„ì•¼ í•¨
    """
    off_assignments = {staff['id']: [] for staff in staff_list}
    off_needed_per_staff = week_data['off_target'] // TOTAL_STAFF  # 1 or 2
    
    # ë‚ ì§œë³„ ë‚¨ì€ ìë¦¬ ìˆ˜ ì´ˆê¸°í™”
    remaining_slots = week_data['daily_slots'].copy()
    
    for staff in staff_list:
        assigned_days = 0
        staff_id = staff['id']
        
        # ìš°ì„ ìˆœìœ„ ë‚ ì§œ ë¦¬ìŠ¤íŠ¸ ìƒì„±
        priority_dates = get_priority_dates(
            staff,
            remaining_slots,
            previous_assignments
        )
        
        for date in priority_dates:
            if assigned_days >= off_needed_per_staff:
                break
            
            if remaining_slots[date] > 0:
                off_assignments[staff_id].append(date)
                remaining_slots[date] -= 1
                assigned_days += 1
        
        # ë°°ì • ëª»í•œ ê²½ìš° ê²½ê³ 
        if assigned_days < off_needed_per_staff:
            log_warning(f"ì§ì› {staff_id}: ì˜¤í”„ {assigned_days}/{off_needed_per_staff}ë§Œ ë°°ì •ë¨")
    
    return off_assignments


def get_priority_dates(staff, remaining_slots, previous_assignments):
    """
    ì§ì›ë³„ ì˜¤í”„ ë°°ì • ìš°ì„ ìˆœìœ„ ë‚ ì§œ ê²°ì •
    
    ìš°ì„ ìˆœìœ„:
        1. ìë¦¬ ì—¬ìœ  ë§ì€ ë‚ 
        2. ì•¼ê°„ ê·¼ë¬´ ì ì€ ì§ì› â†’ ì•¼ê°„ ë§ì€ ë‚  ìš°ì„ 
        3. ì£¼ë§ ê·¼ë¬´ ì ì€ ì§ì› â†’ í† ìš”ì¼ ìš°ì„ 
        4. ì—°ì† ê·¼ë¬´ ë°©ì§€
    """
    dates = list(remaining_slots.keys())
    
    # ê° ë‚ ì§œì— ì ìˆ˜ ë¶€ì—¬
    date_scores = {}
    for date in dates:
        score = 0
        
        # 1. ë‚¨ì€ ìë¦¬ (ë§ì„ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
        score += remaining_slots[date] * 10
        
        # 2. ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„±
        if is_night_shift_day(date):
            night_count = get_staff_night_count(staff, previous_assignments)
            avg_night = get_average_night_count(previous_assignments)
            if night_count < avg_night:
                score += 5
        
        # 3. ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„±
        if date.weekday() == 5:  # í† ìš”ì¼
            weekend_count = get_staff_weekend_count(staff, previous_assignments)
            avg_weekend = get_average_weekend_count(previous_assignments)
            if weekend_count < avg_weekend:
                score += 5
        
        # 4. ì—°ì† ê·¼ë¬´ ë°©ì§€
        if would_break_consecutive_work(staff, date, previous_assignments):
            score += 3
        
        date_scores[date] = score
    
    # ì ìˆ˜ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
    sorted_dates = sorted(dates, key=lambda d: date_scores[d], reverse=True)
    
    return sorted_dates
```

---

## 5.2 ì—°ì°¨ ì‹ ì²­ ê²€ì¦

```python
def validate_annual_leave_request(date, staff_id, week_data, current_requests):
    """
    ì—°ì°¨ ì‹ ì²­ ê°€ëŠ¥ ì—¬ë¶€ ê²€ì¦
    
    Args:
        date: ì‹ ì²­í•  ë‚ ì§œ
        staff_id: ì§ì› ID
        week_data: ì£¼ì°¨ ì •ë³´
        current_requests: í˜„ì¬ê¹Œì§€ì˜ ì‹ ì²­ ë‚´ì—­
        
    Returns:
        dict: {
            'valid': bool,
            'reason': str  # ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ì´ìœ 
        }
        
    ê²€ì¦ ê·œì¹™:
        1. í•´ë‹¹ ë‚ ì§œê°€ ì£¼ì°¨ ë²”ìœ„ ë‚´ì¸ì§€
        2. ì˜¤í”„ ë°°ì •ì´ ì™„ë£Œëœ í›„ì¸ì§€
        3. ë‚¨ì€ ì—°ì°¨ ìë¦¬ê°€ ìˆëŠ”ì§€
        4. ì´ë¯¸ ì˜¤í”„ë¡œ ë°°ì •ëœ ë‚ ì§œëŠ” ì•„ë‹Œì§€
    """
    # 1. ë‚ ì§œ ë²”ìœ„ í™•ì¸
    if date < week_data['week_start'] or date > week_data['week_end']:
        return {
            'valid': False,
            'reason': 'í•´ë‹¹ ì£¼ì°¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ë‚ ì§œì…ë‹ˆë‹¤'
        }
    
    # 2. ì˜¤í”„ ë°°ì • í™•ì¸
    if not is_off_assignment_completed(week_data):
        return {
            'valid': False,
            'reason': 'ì˜¤í”„ ë°°ì •ì´ ì™„ë£Œëœ í›„ ì—°ì°¨ ì‹ ì²­ ê°€ëŠ¥í•©ë‹ˆë‹¤'
        }
    
    # 3. ë‚¨ì€ ìë¦¬ í™•ì¸
    used_annual = count_annual_on_date(date, current_requests)
    used_off = count_off_on_date(date, current_requests)
    available_slots = week_data['daily_slots'][date]
    
    remaining = available_slots - used_off - used_annual
    
    if remaining <= 0:
        return {
            'valid': False,
            'reason': f'í•´ë‹¹ ë‚ ì§œì˜ íœ´ë¬´ ìë¦¬ê°€ ëª¨ë‘ ì°¼ìŠµë‹ˆë‹¤ (ì´ {available_slots}ìë¦¬)'
        }
    
    # 4. ì¤‘ë³µ í™•ì¸
    if is_already_off(staff_id, date, current_requests):
        return {
            'valid': False,
            'reason': 'ì´ë¯¸ ì˜¤í”„ë¡œ ë°°ì •ëœ ë‚ ì§œì…ë‹ˆë‹¤'
        }
    
    # 5. ì£¼ì°¨ë³„ ì—°ì°¨ í•œë„ í™•ì¸
    week_annual_used = count_week_annual(week_data, current_requests)
    week_annual_available = week_data['annual_available']
    
    if week_annual_used >= week_annual_available:
        return {
            'valid': False,
            'reason': f'ì´ë²ˆ ì£¼ ì—°ì°¨ ê°€ëŠ¥ ìë¦¬ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤ ({week_annual_available}ìë¦¬)'
        }
    
    return {
        'valid': True,
        'reason': ''
    }


# ì‚¬ìš© ì˜ˆì‹œ
validation = validate_annual_leave_request(
    date=datetime(2025, 1, 6),
    staff_id='staff_001',
    week_data=week_data,
    current_requests=current_requests
)

if not validation['valid']:
    print(f"ì—°ì°¨ ì‹ ì²­ ë¶ˆê°€: {validation['reason']}")
```

---

## 5.3 ì˜¤í”„/ì—°ì°¨ í†µí•© ê²€ì¦

```python
def validate_week_assignments(week_data, off_assignments, annual_requests):
    """
    ì£¼ì°¨ë³„ ì˜¤í”„/ì—°ì°¨ ë°°ì •ì˜ ì •í•©ì„± ê²€ì¦
    
    Args:
        week_data: ì£¼ì°¨ ì •ë³´
        off_assignments: ì˜¤í”„ ë°°ì • ê²°ê³¼
        annual_requests: ì—°ì°¨ ì‹ ì²­ ê²°ê³¼
        
    Returns:
        dict: {
            'valid': bool,
            'errors': list,      # ì˜¤ë¥˜ ëª©ë¡
            'warnings': list     # ê²½ê³  ëª©ë¡
        }
        
    ê²€ì¦ í•­ëª©:
        1. ê° ë‚ ì§œì˜ ì˜¤í”„+ì—°ì°¨ <= ê°€ìš© ìë¦¬
        2. ê° ì§ì›ì˜ ì˜¤í”„ = ëª©í‘œ (1ì¼ or 2ì¼)
        3. ì´ ì˜¤í”„ = off_target
        4. ì´ ì—°ì°¨ <= annual_available
    """
    result = {
        'valid': True,
        'errors': [],
        'warnings': []
    }
    
    # 1. ë‚ ì§œë³„ ìë¦¬ ê²€ì¦
    for date, available in week_data['daily_slots'].items():
        off_count = count_staff_with_off_on_date(date, off_assignments)
        annual_count = count_staff_with_annual_on_date(date, annual_requests)
        total_used = off_count + annual_count
        
        if total_used > available:
            result['valid'] = False
            result['errors'].append(
                f"{date.strftime('%Y-%m-%d')}: "
                f"ìë¦¬ ì´ˆê³¼ (ì‚¬ìš© {total_used} > ê°€ìš© {available})"
            )
        elif total_used < available:
            result['warnings'].append(
                f"{date.strftime('%Y-%m-%d')}: "
                f"ì—¬ìœ  ìë¦¬ ìˆìŒ ({available - total_used}ìë¦¬)"
            )
    
    # 2. ì§ì›ë³„ ì˜¤í”„ ê²€ì¦
    off_per_staff = week_data['off_target'] // TOTAL_STAFF
    for staff_id, off_dates in off_assignments.items():
        if len(off_dates) != off_per_staff:
            result['valid'] = False
            result['errors'].append(
                f"ì§ì› {staff_id}: ì˜¤í”„ {len(off_dates)}ì¼ "
                f"(ëª©í‘œ {off_per_staff}ì¼)"
            )
    
    # 3. ì´ ì˜¤í”„ ê²€ì¦
    total_off = sum(len(dates) for dates in off_assignments.values())
    if total_off != week_data['off_target']:
        result['valid'] = False
        result['errors'].append(
            f"ì´ ì˜¤í”„ ë¶ˆì¼ì¹˜: {total_off} != {week_data['off_target']}"
        )
    
    # 4. ì´ ì—°ì°¨ ê²€ì¦
    total_annual = sum(len(dates) for dates in annual_requests.values())
    if total_annual > week_data['annual_available']:
        result['valid'] = False
        result['errors'].append(
            f"ì—°ì°¨ ì´ˆê³¼: {total_annual} > {week_data['annual_available']}"
        )
    
    return result
```

---

# 6. ê²€ì¦ ê·œì¹™

## 6.1 í•„ìˆ˜ ê²€ì¦ (ì €ì¥ ë¶ˆê°€)

```python
class MandatoryValidations:
    """
    ì €ì¥ ì‹œ ë°˜ë“œì‹œ í†µê³¼í•´ì•¼ í•˜ëŠ” ê²€ì¦
    í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ì €ì¥ ë¶ˆê°€
    """
    
    @staticmethod
    def validate_total_count(date, assignments):
        """
        ë°°ì¹˜ + ì˜¤í”„ + ì—°ì°¨ = 20ëª…
        """
        placed = len(assignments['placed'])
        off = len(assignments['off'])
        annual = len(assignments['annual'])
        total = placed + off + annual
        
        if total != TOTAL_STAFF:
            return {
                'valid': False,
                'error': f"{date}: ì´ ì¸ì› {total}ëª… != 20ëª… "
                        f"(ë°°ì¹˜ {placed} + ì˜¤í”„ {off} + ì—°ì°¨ {annual})"
            }
        return {'valid': True}
    
    @staticmethod
    def validate_grade_count(date, placed_staff, required_grades):
        """
        ë“±ê¸‰ë³„ í•„ìš” ì¸ì› ì¶©ì¡±
        """
        actual_grades = count_by_grade(placed_staff)
        
        errors = []
        for grade, required in required_grades.items():
            actual = actual_grades.get(grade, 0)
            if actual != required:
                errors.append(
                    f"{grade}: {actual}ëª… != {required}ëª…"
                )
        
        if errors:
            return {
                'valid': False,
                'error': f"{date}: ë“±ê¸‰ë³„ ì¸ì› ë¶ˆì¼ì¹˜ - {', '.join(errors)}"
            }
        return {'valid': True}
    
    @staticmethod
    def validate_no_duplicate(date, all_assignments):
        """
        í•œ ì§ì›ì´ ë°°ì¹˜/ì˜¤í”„/ì—°ì°¨ ì¤‘ë³µ ë¶ˆê°€
        """
        all_staff_ids = []
        all_staff_ids.extend(all_assignments['placed'])
        all_staff_ids.extend(all_assignments['off'])
        all_staff_ids.extend(all_assignments['annual'])
        
        if len(all_staff_ids) != len(set(all_staff_ids)):
            duplicates = find_duplicates(all_staff_ids)
            return {
                'valid': False,
                'error': f"{date}: ì¤‘ë³µ ë°°ì • - {duplicates}"
            }
        return {'valid': True}
    
    @staticmethod
    def validate_work_days_per_week(week_assignments):
        """
        ì£¼ 4ì¼ ê·¼ë¬´ ì¤€ìˆ˜
        """
        for staff_id in range(TOTAL_STAFF):
            work_days = count_work_days_in_week(staff_id, week_assignments)
            
            # íœ´ë¬´ì¼ í¬í•¨ ì£¼: 3~5ì¼
            # ì •ìƒ ì£¼: 4ì¼
            if work_days < 3 or work_days > 5:
                return {
                    'valid': False,
                    'error': f"ì§ì› {staff_id}: ì£¼ ê·¼ë¬´ì¼ {work_days}ì¼ (3~5ì¼ ë²”ìœ„ ë²—ì–´ë‚¨)"
                }
        
        return {'valid': True}
```

---

## 6.2 ê¶Œì¥ ê²€ì¦ (ê²½ê³ ë§Œ)

```python
class RecommendedValidations:
    """
    ê¶Œì¥ ì‚¬í•­ ê²€ì¦
    ì‹¤íŒ¨í•´ë„ ì €ì¥ ê°€ëŠ¥í•˜ì§€ë§Œ ê²½ê³  í‘œì‹œ
    """
    
    @staticmethod
    def check_consecutive_work(staff_id, assignments, max_consecutive=5):
        """
        ì—°ì† ê·¼ë¬´ì¼ ì²´í¬
        """
        work_dates = get_work_dates(staff_id, assignments)
        work_dates.sort()
        
        max_streak = 1
        current_streak = 1
        
        for i in range(1, len(work_dates)):
            diff = (work_dates[i] - work_dates[i-1]).days
            
            if diff == 1:
                current_streak += 1
                max_streak = max(max_streak, current_streak)
            else:
                current_streak = 1
        
        if max_streak > max_consecutive:
            return {
                'warning': True,
                'message': f"ì§ì› {staff_id}: ìµœëŒ€ {max_streak}ì¼ ì—°ì† ê·¼ë¬´ "
                          f"(ê¶Œì¥ {max_consecutive}ì¼ ì´í•˜)"
            }
        
        return {'warning': False}
    
    @staticmethod
    def check_night_shift_fairness(month_assignments, tolerance=1):
        """
        ì•¼ê°„ ê·¼ë¬´ í˜•í‰ì„± ì²´í¬
        """
        night_counts = {}
        for staff_id in range(TOTAL_STAFF):
            night_counts[staff_id] = count_night_shifts(staff_id, month_assignments)
        
        avg = sum(night_counts.values()) / TOTAL_STAFF
        warnings = []
        
        for staff_id, count in night_counts.items():
            if abs(count - avg) > tolerance:
                warnings.append(
                    f"ì§ì› {staff_id}: ì•¼ê°„ {count}íšŒ (í‰ê·  {avg:.1f}íšŒ)"
                )
        
        if warnings:
            return {
                'warning': True,
                'message': "ì•¼ê°„ ê·¼ë¬´ í¸ì°¨ í¼: " + ", ".join(warnings)
            }
        
        return {'warning': False}
    
    @staticmethod
    def check_weekend_fairness(month_assignments, tolerance=1):
        """
        ì£¼ë§ ê·¼ë¬´ í˜•í‰ì„± ì²´í¬
        """
        weekend_counts = {}
        for staff_id in range(TOTAL_STAFF):
            weekend_counts[staff_id] = count_weekend_shifts(staff_id, month_assignments)
        
        avg = sum(weekend_counts.values()) / TOTAL_STAFF
        warnings = []
        
        for staff_id, count in weekend_counts.items():
            if abs(count - avg) > tolerance:
                warnings.append(
                    f"ì§ì› {staff_id}: ì£¼ë§ {count}íšŒ (í‰ê·  {avg:.1f}íšŒ)"
                )
        
        if warnings:
            return {
                'warning': True,
                'message': "ì£¼ë§ ê·¼ë¬´ í¸ì°¨ í¼: " + ", ".join(warnings)
            }
        
        return {'warning': False}
```

---

# 7. í•¨ìˆ˜ êµ¬í˜„ ì˜ˆì‹œ

## 7.1 ì›”ê°„ ë°°ì¹˜ ë©”ì¸ í•¨ìˆ˜

```python
def assign_monthly_schedule(year, month, doctor_schedules, off_requests, annual_requests):
    """
    ì›”ê°„ ìŠ¤ì¼€ì¤„ ìë™ ë°°ì¹˜ ë©”ì¸ í•¨ìˆ˜
    
    Args:
        year: ë…„ë„
        month: ì›”
        doctor_schedules: ì›ì¥ ìŠ¤ì¼€ì¤„ dict {date: schedule}
        off_requests: ì˜¤í”„ ì‹ ì²­ dict {staff_id: [dates]}
        annual_requests: ì—°ì°¨ ì‹ ì²­ dict {staff_id: [dates]}
        
    Returns:
        dict: {
            'success': bool,
            'assignments': dict,  # ìµœì¢… ë°°ì¹˜ ê²°ê³¼
            'errors': list,
            'warnings': list
        }
    """
    try:
        # 1. ë°°ì • ë²”ìœ„ ê²°ì •
        assignment_range = get_month_assignment_range(year, month)
        
        # 2. ì£¼ì°¨ë³„ ìë¦¬ ê³„ì‚°
        month_slots = calculate_month_slots(year, month, doctor_schedules)
        
        # 3. ì´ì›”ëœ ì£¼ ì²˜ë¦¬
        if assignment_range['carryover_week']:
            carryover_assignments = assignment_range['carryover_week']['assignments']
        else:
            carryover_assignments = {}
        
        # 4. ì£¼ì°¨ë³„ ì˜¤í”„ ìë™ ë°°ì •
        all_off_assignments = carryover_assignments.copy()
        
        for week_info in assignment_range['new_weeks']:
            week_data = next(w for w in month_slots['weeks'] 
                           if w['week_number'] == week_info[2])
            
            # ì‚¬ìš©ì ì‹ ì²­ ìš°ì„  ë°˜ì˜
            pre_assigned_off = filter_week_requests(
                off_requests,
                week_data['week_start'],
                week_data['week_end']
            )
            
            # ë¯¸ì‹ ì²­ì ìë™ ë°°ì •
            auto_off = auto_assign_off(
                week_data,
                get_unassigned_staff(pre_assigned_off),
                all_off_assignments
            )
            
            # ë³‘í•©
            week_off = merge_assignments(pre_assigned_off, auto_off)
            all_off_assignments.update(week_off)
        
        # 5. ì—°ì°¨ ì‹ ì²­ ê²€ì¦ ë° ë°˜ì˜
        validated_annual = validate_annual_requests(
            annual_requests,
            month_slots,
            all_off_assignments
        )
        
        # 6. ì§ì› ë°°ì¹˜
        staff_assignments = assign_staff_to_dates(
            assignment_range,
            doctor_schedules,
            all_off_assignments,
            validated_annual
        )
        
        # 7. ìµœì¢… ê²€ì¦
        validation_result = validate_all_assignments(
            staff_assignments,
            month_slots
        )
        
        if not validation_result['valid']:
            return {
                'success': False,
                'assignments': None,
                'errors': validation_result['errors'],
                'warnings': []
            }
        
        # 8. ê²°ê³¼ ë°˜í™˜
        return {
            'success': True,
            'assignments': staff_assignments,
            'errors': [],
            'warnings': validation_result['warnings']
        }
        
    except Exception as e:
        return {
            'success': False,
            'assignments': None,
            'errors': [f"ë°°ì¹˜ ì‹¤íŒ¨: {str(e)}"],
            'warnings': []
        }
```

---

## 7.2 ì§ì› ë°°ì¹˜ í•¨ìˆ˜

```python
def assign_staff_to_dates(assignment_range, doctor_schedules, 
                          off_assignments, annual_assignments):
    """
    ë‚ ì§œë³„ ì§ì› ë°°ì¹˜
    
    ë¡œì§:
        1. ë‚ ì§œë³„ ìˆœíšŒ
        2. ì˜¤í”„/ì—°ì°¨ ì§ì› ì œì™¸
        3. í•„ìš” ë“±ê¸‰ë³„ ì¸ì› ì„ íƒ
        4. í˜•í‰ì„± ê³ ë ¤í•˜ì—¬ ë°°ì¹˜
    """
    all_assignments = {}
    staff_list = get_all_staff()
    
    # ë‚ ì§œë³„ ìˆœíšŒ
    current_date = assignment_range['range_start']
    while current_date <= assignment_range['range_end']:
        # ì¼ìš”ì¼ ì œì™¸
        if current_date.weekday() == 6:
            current_date += timedelta(days=1)
            continue
        
        # ì›ì¥ ìŠ¤ì¼€ì¤„ í™•ì¸
        doctor_schedule = doctor_schedules.get(current_date)
        if not doctor_schedule:
            current_date += timedelta(days=1)
            continue
        
        # í•„ìš” ì¸ì›
        required_grades = get_required_grades(doctor_schedule)
        
        # ì œì™¸í•  ì§ì› (ì˜¤í”„/ì—°ì°¨)
        excluded_staff = set()
        for staff_id, dates in off_assignments.items():
            if current_date in dates:
                excluded_staff.add(staff_id)
        for staff_id, dates in annual_assignments.items():
            if current_date in dates:
                excluded_staff.add(staff_id)
        
        # ê°€ìš© ì§ì›
        available_staff = [s for s in staff_list 
                          if s['id'] not in excluded_staff]
        
        # ë“±ê¸‰ë³„ ì„ íƒ
        selected_staff = select_staff_by_grade(
            available_staff,
            required_grades,
            current_date,
            all_assignments  # í˜•í‰ì„± ê³„ì‚°ìš©
        )
        
        # ë°°ì¹˜ ì €ì¥
        all_assignments[current_date] = {
            'placed': [s['id'] for s in selected_staff],
            'off': [s for s in off_assignments.keys() 
                   if current_date in off_assignments[s]],
            'annual': [s for s in annual_assignments.keys() 
                      if current_date in annual_assignments[s]],
            'doctor_schedule': doctor_schedule
        }
        
        current_date += timedelta(days=1)
    
    return all_assignments


def select_staff_by_grade(available_staff, required_grades, 
                          date, previous_assignments):
    """
    ë“±ê¸‰ë³„ í•„ìš” ì¸ì›ë§Œí¼ ì„ íƒ
    
    ìš°ì„ ìˆœìœ„:
        1. ì´ë²ˆ ë‹¬ ì´ ê·¼ë¬´ì¼ ì ì€ ì§ì›
        2. ì•¼ê°„ ê·¼ë¬´ ì ì€ ì§ì› (ì•¼ê°„ì¼ ê²½ìš°)
        3. ì£¼ë§ ê·¼ë¬´ ì ì€ ì§ì› (í† ìš”ì¼ ê²½ìš°)
        4. ì—°ì† ê·¼ë¬´ì¼ ì ì€ ì§ì›
    """
    selected = []
    
    for grade, count in required_grades.items():
        # í•´ë‹¹ ë“±ê¸‰ ì§ì›ë§Œ
        grade_staff = [s for s in available_staff 
                      if s['grade'] == grade]
        
        # ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
        scored_staff = []
        for staff in grade_staff:
            score = calculate_priority_score(
                staff,
                date,
                previous_assignments
            )
            scored_staff.append((staff, score))
        
        # ì ìˆ˜ ë‚®ì€ ìˆœ ì •ë ¬ (ê·¼ë¬´ ì ì€ ì‚¬ëŒ ìš°ì„ )
        scored_staff.sort(key=lambda x: x[1])
        
        # í•„ìš” ì¸ì›ë§Œí¼ ì„ íƒ
        for i in range(min(count, len(scored_staff))):
            selected.append(scored_staff[i][0])
    
    return selected


def calculate_priority_score(staff, date, previous_assignments):
    """
    ì§ì› ë°°ì¹˜ ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
    
    ì ìˆ˜ê°€ ë‚®ì„ìˆ˜ë¡ ìš°ì„  ë°°ì¹˜
    """
    score = 0
    
    # 1. ì´ë²ˆ ë‹¬ ì´ ê·¼ë¬´ì¼ (ê°€ì¤‘ì¹˜ 10)
    work_days = count_month_work_days(staff['id'], previous_assignments)
    score += work_days * 10
    
    # 2. ì•¼ê°„ ê·¼ë¬´ íšŸìˆ˜ (ì•¼ê°„ì¼ ê²½ìš°, ê°€ì¤‘ì¹˜ 5)
    if is_night_shift_day(date):
        night_count = count_night_shifts(staff['id'], previous_assignments)
        score += night_count * 5
    
    # 3. ì£¼ë§ ê·¼ë¬´ íšŸìˆ˜ (í† ìš”ì¼ì¸ ê²½ìš°, ê°€ì¤‘ì¹˜ 5)
    if date.weekday() == 5:
        weekend_count = count_weekend_shifts(staff['id'], previous_assignments)
        score += weekend_count * 5
    
    # 4. ìµœê·¼ ì—°ì† ê·¼ë¬´ì¼ (ê°€ì¤‘ì¹˜ 3)
    consecutive = count_consecutive_work_days(staff['id'], date, previous_assignments)
    score += consecutive * 3
    
    return score
```

---

# 8. ì£¼ì˜ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸

## 8.1 ê°œë°œ ì „ í™•ì¸ì‚¬í•­

```
â–¡ ì£¼ ë‹¨ìœ„ ê´€ë¦¬ ê°œë… ì´í•´
  - ì›”~í†  6ì¼ì´ 1ì£¼
  - ì¼ìš”ì¼ì€ íœ´ë¬´ë¡œ ë³„ë„ ì²˜ë¦¬
  
â–¡ ì›” ê²½ê³„ ì²˜ë¦¬ ë°©ë²• ì´í•´
  - ì´ì „ ë‹¬ ë§ˆì§€ë§‰ ì£¼ ì´ì›”
  - ë‹¤ìŒ ë‹¬ ì²« ì£¼ê¹Œì§€ í¬í•¨
  
â–¡ ìë¦¬ ê³„ì‚° ê³µì‹ ìˆ™ì§€
  - íœ´ë¬´ ê°€ëŠ¥ = ì´ ì¸ì› - í•„ìš” ë°°ì¹˜
  - ì˜¤í”„ ëª©í‘œ = ì •ìƒ ì£¼ 40, íœ´ë¬´ í¬í•¨ ì£¼ 20
  - ì—°ì°¨ ê°€ëŠ¥ = ì´ ìë¦¬ - ì˜¤í”„ ëª©í‘œ
  
â–¡ í•„ìˆ˜ ê²€ì¦ ê·œì¹™ ì •ë¦¬
  - ì´ ì¸ì› = 20ëª… (í•­ìƒ)
  - ë“±ê¸‰ë³„ ì¸ì› ì¶©ì¡±
  - ì£¼ 4ì¼ ê·¼ë¬´ ì¤€ìˆ˜
```

---

## 8.2 êµ¬í˜„ ì‹œ ì£¼ì˜ì‚¬í•­

```python
# âŒ ì˜ëª»ëœ ì˜ˆì‹œ
def wrong_calculate_slots():
    # ì¼ìš”ì¼ì„ í¬í•¨í•´ì„œ ê³„ì‚° (X)
    total_slots = 0
    for day in range(7):  # ì›”~ì¼ 7ì¼
        total_slots += calculate_daily_slots(day)
    
    # ê³ ì •ëœ 40ìë¦¬ë¡œ ê³„ì‚° (X)
    off_target = 40  # í•­ìƒ 40ìë¦¬?
    
    return total_slots, off_target


# âœ… ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
def correct_calculate_slots(week_start, week_end):
    # ì¼ìš”ì¼ ì œì™¸í•˜ê³  ê³„ì‚° (O)
    total_slots = 0
    has_holiday = False
    
    current = week_start
    while current <= week_end:
        if current.weekday() == 6:  # ì¼ìš”ì¼
            has_holiday = True
            current += timedelta(days=1)
            continue
        
        total_slots += calculate_daily_slots(current)
        current += timedelta(days=1)
    
    # íœ´ë¬´ì¼ ì—¬ë¶€ì— ë”°ë¼ ì˜¤í”„ ëª©í‘œ ê³„ì‚° (O)
    off_target = 20 if has_holiday else 40
    annual_available = total_slots - off_target
    
    return {
        'total_slots': total_slots,
        'off_target': off_target,
        'annual_available': max(0, annual_available),  # ìŒìˆ˜ ë°©ì§€
        'has_holiday': has_holiday
    }
```

---

## 8.3 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- ì£¼ì°¨ ì •ë³´ í…Œì´ë¸”
CREATE TABLE weeks (
    id INTEGER PRIMARY KEY,
    year INTEGER NOT NULL,
    month INTEGER NOT NULL,
    week_number INTEGER NOT NULL,
    week_start DATE NOT NULL,
    week_end DATE NOT NULL,
    total_slots INTEGER NOT NULL,      -- ì´ íœ´ë¬´ ê°€ëŠ¥ ìë¦¬
    off_target INTEGER NOT NULL,       -- ì˜¤í”„ ë°°ì • ëª©í‘œ
    annual_available INTEGER NOT NULL, -- ì—°ì°¨ ê°€ëŠ¥ ìë¦¬
    has_holiday BOOLEAN NOT NULL,      -- íœ´ë¬´ì¼ í¬í•¨ ì—¬ë¶€
    is_locked BOOLEAN DEFAULT FALSE,   -- ì´ì›”ë˜ì–´ ìˆ˜ì • ë¶ˆê°€
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(year, month, week_number)
);

-- ë‚ ì§œë³„ ìë¦¬ ì •ë³´
CREATE TABLE daily_slots (
    id INTEGER PRIMARY KEY,
    date DATE NOT NULL UNIQUE,
    weekday INTEGER NOT NULL,          -- 0=ì›”, 5=í† , 6=ì¼
    week_id INTEGER REFERENCES weeks(id),
    required_staff INTEGER NOT NULL,   -- í•„ìš” ë°°ì¹˜ ì¸ì›
    available_slots INTEGER NOT NULL,  -- íœ´ë¬´ ê°€ëŠ¥ ìë¦¬
    used_off INTEGER DEFAULT 0,        -- ì‚¬ìš©ëœ ì˜¤í”„ ìë¦¬
    used_annual INTEGER DEFAULT 0,     -- ì‚¬ìš©ëœ ì—°ì°¨ ìë¦¬
    remaining_slots INTEGER GENERATED ALWAYS AS 
        (available_slots - used_off - used_annual) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì˜¤í”„/ì—°ì°¨ ë°°ì •
CREATE TABLE assignments (
    id INTEGER PRIMARY KEY,
    date DATE NOT NULL,
    staff_id INTEGER NOT NULL,
    type VARCHAR(10) NOT NULL,  -- 'off' or 'annual' or 'work'
    is_auto_assigned BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(date, staff_id),
    FOREIGN KEY (date) REFERENCES daily_slots(date),
    CHECK (type IN ('off', 'annual', 'work'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_weeks_year_month ON weeks(year, month);
CREATE INDEX idx_daily_slots_date ON daily_slots(date);
CREATE INDEX idx_assignments_date ON assignments(date);
CREATE INDEX idx_assignments_staff ON assignments(staff_id);
CREATE INDEX idx_assignments_type ON assignments(type);
```

---

## 8.4 í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

```python
def test_week_calculation():
    """ì£¼ì°¨ ê³„ì‚° í…ŒìŠ¤íŠ¸"""
    # 1. ì •ìƒ ì£¼ (ì¼ìš”ì¼ ì—†ìŒ)
    week_start = datetime(2025, 1, 6)  # ì›”ìš”ì¼
    week_end = datetime(2025, 1, 11)   # í† ìš”ì¼
    
    result = calculate_week_slots(week_start, week_end, schedules)
    
    assert result['has_holiday'] == False
    assert result['off_target'] == 40  # 20ëª… Ã— 2ì¼
    assert result['total_slots'] == 44  # 6+6+6+6+6+14
    assert result['annual_available'] == 4  # 44 - 40
    
    # 2. íœ´ë¬´ì¼ í¬í•¨ ì£¼
    week_start = datetime(2024, 12, 30)  # ì›”ìš”ì¼
    week_end = datetime(2025, 1, 4)      # í† ìš”ì¼ (1/1 ì¼ìš”ì¼ í¬í•¨)
    
    result = calculate_week_slots(week_start, week_end, schedules)
    
    assert result['has_holiday'] == True
    assert result['off_target'] == 20  # 20ëª… Ã— 1ì¼
    assert result['total_slots'] == 38  # 6+6+0+6+6+14
    assert result['annual_available'] == 18  # 38 - 20


def test_total_count_validation():
    """ì´ ì¸ì› ê²€ì¦ í…ŒìŠ¤íŠ¸"""
    date = datetime(2025, 1, 6)
    
    # ì •ìƒ ì¼€ì´ìŠ¤
    assignments = {
        'placed': list(range(14)),  # 14ëª… ë°°ì¹˜
        'off': list(range(14, 19)),  # 5ëª… ì˜¤í”„
        'annual': [19]  # 1ëª… ì—°ì°¨
    }
    result = MandatoryValidations.validate_total_count(date, assignments)
    assert result['valid'] == True
    
    # ì˜¤ë¥˜ ì¼€ì´ìŠ¤ - ì¸ì› ì´ˆê³¼
    assignments = {
        'placed': list(range(15)),  # 15ëª… ë°°ì¹˜
        'off': list(range(15, 20)),  # 5ëª… ì˜¤í”„
        'annual': [20]  # 1ëª… ì—°ì°¨
    }
    result = MandatoryValidations.validate_total_count(date, assignments)
    assert result['valid'] == False
    assert '21ëª…' in result['error']


def test_month_boundary():
    """ì›” ê²½ê³„ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
    # 2025ë…„ 2ì›” ë°°ì •
    range_info = get_month_assignment_range(2025, 2)
    
    # 1ì£¼ì°¨ëŠ” 1ì›”ì— ë°°ì •ë˜ì–´ ì´ì›”ë¨
    assert range_info['carryover_week'] is not None
    assert range_info['carryover_week']['week_start'] == datetime(2025, 1, 27)
    assert range_info['carryover_week']['is_locked'] == True
    
    # ìƒˆë¡œ ë°°ì •í•  ì£¼ëŠ” 2ì£¼ì°¨ë¶€í„°
    assert len(range_info['new_weeks']) == 4
    assert range_info['new_weeks'][0][0] == datetime(2025, 2, 3)  # 2ì£¼ì°¨ ì‹œì‘
    
    # ë§ˆì§€ë§‰ ì£¼ëŠ” 3ì›” 1ì¼ê¹Œì§€ í¬í•¨
    assert range_info['next_month_week'] is not None
    assert range_info['range_end'] == datetime(2025, 3, 1)
```

---

## 8.5 ì„±ëŠ¥ ìµœì í™”

```python
# âŒ ë¹„íš¨ìœ¨ì ì¸ ì½”ë“œ
def inefficient_count_work_days(staff_id, all_assignments):
    count = 0
    for date, assignments in all_assignments.items():
        if staff_id in assignments['placed']:
            count += 1
    return count  # O(n) - ë§¤ë²ˆ ì „ì²´ ìˆœíšŒ


# âœ… íš¨ìœ¨ì ì¸ ì½”ë“œ
class AssignmentCache:
    """ë°°ì • ì •ë³´ ìºì‹±"""
    
    def __init__(self):
        self.staff_work_days = {}  # {staff_id: [dates]}
        self.staff_night_count = {}
        self.staff_weekend_count = {}
        self.date_assignments = {}
    
    def add_assignment(self, date, staff_id, is_night, is_weekend):
        """ë°°ì • ì¶”ê°€ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸"""
        # ê·¼ë¬´ì¼ ì¶”ê°€
        if staff_id not in self.staff_work_days:
            self.staff_work_days[staff_id] = []
        self.staff_work_days[staff_id].append(date)
        
        # ì•¼ê°„ ì¹´ìš´íŠ¸
        if is_night:
            self.staff_night_count[staff_id] = \
                self.staff_night_count.get(staff_id, 0) + 1
        
        # ì£¼ë§ ì¹´ìš´íŠ¸
        if is_weekend:
            self.staff_weekend_count[staff_id] = \
                self.staff_weekend_count.get(staff_id, 0) + 1
        
        # ë‚ ì§œë³„ ë°°ì •
        self.date_assignments[date] = staff_id
    
    def get_work_day_count(self, staff_id):
        """O(1) ì¡°íšŒ"""
        return len(self.staff_work_days.get(staff_id, []))
    
    def get_night_count(self, staff_id):
        """O(1) ì¡°íšŒ"""
        return self.staff_night_count.get(staff_id, 0)
    
    def get_weekend_count(self, staff_id):
        """O(1) ì¡°íšŒ"""
        return self.staff_weekend_count.get(staff_id, 0)
```

---

## 8.6 ì—ëŸ¬ ì²˜ë¦¬

```python
class ScheduleError(Exception):
    """ìŠ¤ì¼€ì¤„ ê´€ë ¨ ê¸°ë³¸ ì˜ˆì™¸"""
    pass

class InsufficientSlotsError(ScheduleError):
    """ìë¦¬ ë¶€ì¡± ì˜ˆì™¸"""
    def __init__(self, date, required, available):
        self.date = date
        self.required = required
        self.available = available
        super().__init__(
            f"{date}: ìë¦¬ ë¶€ì¡± (í•„ìš” {required} > ê°€ìš© {available})"
        )

class ValidationError(ScheduleError):
    """ê²€ì¦ ì‹¤íŒ¨ ì˜ˆì™¸"""
    def __init__(self, errors):
        self.errors = errors
        super().__init__(
            f"ê²€ì¦ ì‹¤íŒ¨: {len(errors)}ê°œ ì˜¤ë¥˜\n" + 
            "\n".join(f"- {e}" for e in errors)
        )

class CarryoverNotFoundError(ScheduleError):
    """ì´ì›” ë°ì´í„° ì—†ìŒ ì˜ˆì™¸"""
    def __init__(self, year, month):
        self.year = year
        self.month = month
        super().__init__(
            f"{year}ë…„ {month}ì›”: ì´ì›”ëœ ì£¼ì°¨ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
        )


# ì‚¬ìš© ì˜ˆì‹œ
try:
    result = assign_monthly_schedule(2025, 2, schedules, off_req, annual_req)
    
    if not result['success']:
        raise ValidationError(result['errors'])
        
except InsufficientSlotsError as e:
    logger.error(f"ìë¦¬ ë¶€ì¡±: {e}")
    # ì‚¬ìš©ìì—ê²Œ ìì„¸í•œ ì•ˆë‚´
    show_error_dialog(
        "ìë¦¬ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤",
        f"{e.date.strftime('%Y-%m-%d')} ë‚ ì§œì—\n"
        f"í•„ìš” ì¸ì›: {e.required}ëª…\n"
        f"ê°€ëŠ¥ ì¸ì›: {e.available}ëª…\n\n"
        f"ì›ì¥ ìŠ¤ì¼€ì¤„ì„ ì¡°ì •í•˜ê±°ë‚˜ í•„ìš” ì¸ì›ì„ ì¤„ì—¬ì£¼ì„¸ìš”."
    )
    
except ValidationError as e:
    logger.error(f"ê²€ì¦ ì‹¤íŒ¨: {e.errors}")
    show_error_list_dialog("ë‹¤ìŒ ë¬¸ì œë¥¼ í•´ê²°í•´ì£¼ì„¸ìš”", e.errors)
    
except Exception as e:
    logger.exception("ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜")
    show_error_dialog("ì˜¤ë¥˜ ë°œìƒ", str(e))
```

---

## 8.7 ë¡œê¹…

```python
import logging
from datetime import datetime

# ë¡œê±° ì„¤ì •
def setup_logger():
    logger = logging.getLogger('schedule_system')
    logger.setLevel(logging.DEBUG)
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬
    fh = logging.FileHandler(
        f'logs/schedule_{datetime.now():%Y%m%d}.log',
        encoding='utf-8'
    )
    fh.setLevel(logging.DEBUG)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)
    
    # í¬ë§·
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    fh.setFormatter(formatter)
    ch.setFormatter(formatter)
    
    logger.addHandler(fh)
    logger.addHandler(ch)
    
    return logger


# ì‚¬ìš© ì˜ˆì‹œ
logger = setup_logger()

def calculate_week_slots(week_start, week_end, schedules):
    logger.info(f"ì£¼ì°¨ ìë¦¬ ê³„ì‚° ì‹œì‘: {week_start} ~ {week_end}")
    
    try:
        # ... ê³„ì‚° ë¡œì§ ...
        
        logger.debug(f"ì´ ìë¦¬: {total_slots}, ì˜¤í”„ ëª©í‘œ: {off_target}")
        logger.info(f"ì£¼ì°¨ ìë¦¬ ê³„ì‚° ì™„ë£Œ")
        
        return result
        
    except Exception as e:
        logger.error(f"ì£¼ì°¨ ìë¦¬ ê³„ì‚° ì‹¤íŒ¨: {e}", exc_info=True)
        raise
```

---

# 9. ìš”ì•½

## í•µì‹¬ ê³µì‹ ì •ë¦¬

```python
# 1. íœ´ë¬´ ê°€ëŠ¥ ìë¦¬ (ë‚ ì§œë³„)
available_slots = TOTAL_STAFF(20) - required_staff

# 2. ì˜¤í”„ ëª©í‘œ (ì£¼ë³„)
if has_sunday:
    off_target = TOTAL_STAFF * 1  # 20ìë¦¬
else:
    off_target = TOTAL_STAFF * 2  # 40ìë¦¬

# 3. ì—°ì°¨ ê°€ëŠ¥ (ì£¼ë³„)
annual_available = total_week_slots - off_target
# ìŒìˆ˜ë©´ 0

# 4. ì´ ì¸ì› ë³´ì¡´ (ë‚ ì§œë³„, í•­ìƒ!)
placed + off + annual = TOTAL_STAFF(20)

# 5. ì£¼ ë‹¨ìœ„ ë²”ìœ„
week_start = monday_of_week
week_end = saturday_of_week  # 6ì¼ í›„
# ì¼ìš”ì¼ì€ ë²”ìœ„ì—ì„œ ì œì™¸
```

---

## ê°œë°œ ìˆœì„œ ê¶Œì¥

```
1. ì£¼ì°¨ ê³„ì‚° í•¨ìˆ˜ êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸
   âœ… get_week_range()
   âœ… get_month_weeks()
   âœ… calculate_available_slots()

2. ìë¦¬ ê³„ì‚° í•¨ìˆ˜ êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸
   âœ… calculate_week_slots()
   âœ… calculate_month_slots()

3. ì›” ê²½ê³„ ì²˜ë¦¬ êµ¬í˜„ ë° í…ŒìŠ¤íŠ¸
   âœ… get_previous_month_carryover()
   âœ… include_next_month_week()
   âœ… get_month_assignment_range()

4. ì˜¤í”„/ì—°ì°¨ ë°°ì • ë¡œì§
   âœ… auto_assign_off()
   âœ… validate_annual_leave_request()
   âœ… validate_week_assignments()

5. ê²€ì¦ ì‹œìŠ¤í…œ
   âœ… MandatoryValidations
   âœ… RecommendedValidations

6. ë©”ì¸ ë°°ì¹˜ í•¨ìˆ˜
   âœ… assign_monthly_schedule()
   âœ… assign_staff_to_dates()

7. UI ì—°ë™
   âœ… ë‹¬ë ¥ í™”ë©´
   âœ… ì˜¤í”„/ì—°ì°¨ ê´€ë¦¬
   âœ… í†µê³„ í™”ë©´

8. ìµœì í™” ë° ì™„ì„±ë„
   âœ… ìºì‹±
   âœ… ë¡œê¹…
   âœ… ì—ëŸ¬ ì²˜ë¦¬
```

---

**ë¬¸ì„œ ë**

ê°œë°œ ì¤‘ ê¶ê¸ˆí•œ ì‚¬í•­ì´ë‚˜ ì¶”ê°€ ì„¤ëª…ì´ í•„ìš”í•œ ë¶€ë¶„ì´ ìˆìœ¼ë©´ ì–¸ì œë“  ë¬¸ì˜í•˜ì„¸ìš”!
