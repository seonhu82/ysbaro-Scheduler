# ì—°ì„¸ë°”ë¡œì¹˜ê³¼ ê·¼íƒœê´€ë¦¬ ì‹œìŠ¤í…œ ê°œë°œ ê°€ì´ë“œ

**ì‘ì„±ì¼**: 2025ë…„ 10ì›” 22ì¼  
**ëª©ì **: QR ê¸°ë°˜ ëª¨ë°”ì¼ ì¶œí‡´ê·¼ ì²´í¬ ì‹œìŠ¤í…œ ê°œë°œ ê°€ì´ë“œ  
**ëŒ€ìƒ**: ë°±ì—”ë“œ/í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œì

---

## ğŸ“‘ ëª©ì°¨

1. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#1-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
2. [ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„](#2-ë°ì´í„°ë² ì´ìŠ¤-ì„¤ê³„)
3. [QR í† í° ì‹œìŠ¤í…œ](#3-qr-í† í°-ì‹œìŠ¤í…œ)
4. [ë””ë°”ì´ìŠ¤ í•‘ê±°í”„ë¦°íŒ…](#4-ë””ë°”ì´ìŠ¤-í•‘ê±°í”„ë¦°íŒ…)
5. [ë³´ì•ˆ ê²€ì¦ ë¡œì§](#5-ë³´ì•ˆ-ê²€ì¦-ë¡œì§)
6. [ì´ìƒ íŒ¨í„´ ê°ì§€](#6-ì´ìƒ-íŒ¨í„´-ê°ì§€)
7. [API ëª…ì„¸](#7-api-ëª…ì„¸)
8. [í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„](#8-í”„ë¡ íŠ¸ì—”ë“œ-êµ¬í˜„)
9. [ë°°í¬ ë° ìš´ì˜](#9-ë°°í¬-ë°-ìš´ì˜)
10. [í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ](#10-í…ŒìŠ¤íŠ¸-ê°€ì´ë“œ)

---

# 1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

## 1.1 ì „ì²´ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ì‚¬ìš©ì ë‹¨                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  QR ìŠ¤ìº”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ì§ì› ìŠ¤ë§ˆíŠ¸í°â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ QR í‘œì‹œ ê¸°ê¸°â”‚         â”‚
â”‚  â”‚ (ì¹´ë©”ë¼)    â”‚            â”‚ (íƒœë¸”ë¦¿/PC)  â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                                            â”‚
â”‚         â”‚ HTTPS                                      â”‚
â”‚         â†“                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ QR ì¶œí‡´ê·¼ ì²´í¬ í˜ì´ì§€                   â”‚       â”‚
â”‚  â”‚ (React/Vue.js)                          â”‚       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚ - ì§ì› ì„ íƒ UI                          â”‚       â”‚
â”‚  â”‚ - ì¶œê·¼/í‡´ê·¼ ë²„íŠ¼                        â”‚       â”‚
â”‚  â”‚ - ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘ JS                 â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ ê´€ë¦¬ì ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ                â”‚       â”‚
â”‚  â”‚ (React/Vue.js)                          â”‚       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚ - ì‹¤ì‹œê°„ ì¶œí‡´ê·¼ í˜„í™©                    â”‚       â”‚
â”‚  â”‚ - ì˜ì‹¬ íŒ¨í„´ ì•Œë¦¼                        â”‚       â”‚
â”‚  â”‚ - ë””ë°”ì´ìŠ¤ ê´€ë¦¬                         â”‚       â”‚
â”‚  â”‚ - í†µê³„ ë° ë¦¬í¬íŠ¸                        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ REST API
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ë°±ì—”ë“œ ì„œë²„                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ API ì„œë²„ (Python Flask/FastAPI)         â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚         â”‚                                            â”‚
â”‚         â”œâ”€â†’ QR í† í° ê´€ë¦¬ ëª¨ë“ˆ                       â”‚
â”‚         â”‚   - í† í° ìƒì„±/ê²€ì¦                         â”‚
â”‚         â”‚   - 5ë¶„ ì£¼ê¸° ìë™ ê°±ì‹                      â”‚
â”‚         â”‚                                            â”‚
â”‚         â”œâ”€â†’ ì¶œí‡´ê·¼ ì²´í¬ ëª¨ë“ˆ                        â”‚
â”‚         â”‚   - ì¤‘ë³µ ì²´í¬ ë°©ì§€                         â”‚
â”‚         â”‚   - ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘                     â”‚
â”‚         â”‚   - ê¸°ë¡ ì €ì¥                              â”‚
â”‚         â”‚                                            â”‚
â”‚         â”œâ”€â†’ ë³´ì•ˆ ê²€ì¦ ëª¨ë“ˆ                          â”‚
â”‚         â”‚   - í† í° ìœ íš¨ì„± ê²€ì¦                       â”‚
â”‚         â”‚   - ë””ë°”ì´ìŠ¤ í•‘ê±°í”„ë¦°íŠ¸ ìƒì„±               â”‚
â”‚         â”‚   - ì‹œê°„ëŒ€ ê²€ì¦                            â”‚
â”‚         â”‚                                            â”‚
â”‚         â”œâ”€â†’ ì´ìƒ íŒ¨í„´ ê°ì§€ ëª¨ë“ˆ                     â”‚
â”‚         â”‚   - ì—°ì† ì²´í¬ ê°ì§€                         â”‚
â”‚         â”‚   - ë¹„ì •ìƒ ì‹œê°„ ê°ì§€                       â”‚
â”‚         â”‚   - ê´€ë¦¬ì ì•Œë¦¼ ì „ì†¡                       â”‚
â”‚         â”‚                                            â”‚
â”‚         â””â”€â†’ í†µê³„ ë° ë¦¬í¬íŠ¸ ëª¨ë“ˆ                     â”‚
â”‚             - ì¼/ì›” í†µê³„ ìƒì„±                        â”‚
â”‚             - ê°œì¸ë³„ ë¶„ì„                            â”‚
â”‚             - ì—‘ì…€ ë‹¤ìš´ë¡œë“œ                          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ë°ì´í„°ë² ì´ìŠ¤                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                      â”‚
â”‚  PostgreSQL / MySQL / SQLite                        â”‚
â”‚                                                      â”‚
â”‚  â”œâ”€ qr_tokens (QR í† í°)                             â”‚
â”‚  â”œâ”€ device_info (ë””ë°”ì´ìŠ¤ ì •ë³´)                     â”‚
â”‚  â”œâ”€ attendance_records (ì¶œí‡´ê·¼ ê¸°ë¡)                â”‚
â”‚  â”œâ”€ suspicious_logs (ì˜ì‹¬ íŒ¨í„´ ë¡œê·¸)                â”‚
â”‚  â””â”€ settings (ì‹œìŠ¤í…œ ì„¤ì •)                          â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1.2 ê¸°ìˆ  ìŠ¤íƒ

### ë°±ì—”ë“œ

```python
# ì¶”ì²œ ìŠ¤íƒ
Framework: Flask 3.0+ ë˜ëŠ” FastAPI 0.100+
Database: PostgreSQL 15+ (ë˜ëŠ” SQLite 3.40+)
ORM: SQLAlchemy 2.0+
Authentication: JWT (PyJWT 2.8+)
Task Queue: APScheduler 3.10+ (QR í† í° ìë™ ê°±ì‹ ìš©)
Logging: Python logging + íŒŒì¼ ë¡œí…Œì´ì…˜

# í•„ìˆ˜ íŒ¨í‚¤ì§€
requirements.txt:
```

```txt
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SQLAlchemy==3.1.1
SQLAlchemy==2.0.23
psycopg2-binary==2.9.9  # PostgreSQLìš©
PyJWT==2.8.0
APScheduler==3.10.4
python-dateutil==2.8.2
pytz==2023.3
```

### í”„ë¡ íŠ¸ì—”ë“œ

```javascript
// ì¶”ì²œ ìŠ¤íƒ
Framework: React 18+ ë˜ëŠ” Vue 3+
UI Library: Material-UI ë˜ëŠ” Ant Design
HTTP Client: Axios
QR ìŠ¤ìº”: html5-qrcode
State Management: Redux/Zustand (React) ë˜ëŠ” Pinia (Vue)

// package.json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.6.0",
    "html5-qrcode": "^2.3.8",
    "@mui/material": "^5.14.0",
    "qrcode": "^1.5.3"
  }
}
```

---

# 2. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

## 2.1 ERD

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   staff         â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ id (PK)         â”‚
â”‚ name            â”‚
â”‚ position        â”‚
â”‚ email           â”‚
â”‚ phone           â”‚
â”‚ created_at      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 1:N
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   attendance_records            â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ id (PK)                         â”‚
â”‚ staff_id (FK) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ staff.id
â”‚ check_type                      â”‚
â”‚ check_time                      â”‚
â”‚ device_fingerprint (FK) â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ device_info.fingerprint
â”‚ token_used                      â”‚
â”‚ wifi_ssid                       â”‚
â”‚ ip_address                      â”‚
â”‚ gps_latitude                    â”‚
â”‚ gps_longitude                   â”‚
â”‚ photo_path                      â”‚
â”‚ is_suspicious                   â”‚
â”‚ notes                           â”‚
â”‚ created_at                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ N:1
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   device_info                   â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ fingerprint (PK)                â”‚
â”‚ user_agent                      â”‚
â”‚ platform                        â”‚
â”‚ language                        â”‚
â”‚ screen_width                    â”‚
â”‚ screen_height                   â”‚
â”‚ screen_color_depth              â”‚
â”‚ timezone                        â”‚
â”‚ timezone_offset                 â”‚
â”‚ cpu_cores                       â”‚
â”‚ memory_gb                       â”‚
â”‚ touch_support                   â”‚
â”‚ max_touch_points                â”‚
â”‚ device_nickname                 â”‚
â”‚ first_seen                      â”‚
â”‚ last_seen                       â”‚
â”‚ usage_count                     â”‚
â”‚ is_blocked                      â”‚
â”‚ block_reason                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ 1:N
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   suspicious_logs               â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ id (PK)                         â”‚
â”‚ detected_at                     â”‚
â”‚ pattern_type                    â”‚
â”‚ severity                        â”‚
â”‚ device_fingerprint (FK) â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ device_info.fingerprint
â”‚ staff_ids (JSON)                â”‚
â”‚ description                     â”‚
â”‚ admin_reviewed                  â”‚
â”‚ admin_notes                     â”‚
â”‚ reviewed_at                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   qr_tokens                     â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ id (PK)                         â”‚
â”‚ token                           â”‚
â”‚ created_at                      â”‚
â”‚ expires_at                      â”‚
â”‚ is_active                       â”‚
â”‚ used_count                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   settings                      â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ id (PK)                         â”‚
â”‚ key                             â”‚
â”‚ value                           â”‚
â”‚ description                     â”‚
â”‚ updated_at                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2.2 í…Œì´ë¸” ìƒì„¸ ì •ì˜

### staff (ì§ì› ì •ë³´)

```sql
CREATE TABLE staff (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    position VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_staff_name ON staff(name);
CREATE INDEX idx_staff_active ON staff(is_active);

-- ìƒ˜í”Œ ë°ì´í„°
INSERT INTO staff (name, position, email) VALUES
('ê¹€ìœ ì§„', 'ê³ ë…„ì°¨', 'yujin@example.com'),
('ì´ì†Œì˜', 'ì¤‘ë…„ì°¨', 'soyoung@example.com'),
('ë°•ì§€ë¯¼', 'ì €ë…„ì°¨', 'jimin@example.com');
```

### device_info (ë””ë°”ì´ìŠ¤ ì •ë³´)

```sql
CREATE TABLE device_info (
    fingerprint VARCHAR(64) PRIMARY KEY,
    
    -- ê¸°ë³¸ ì •ë³´
    user_agent TEXT NOT NULL,
    platform VARCHAR(50),
    language VARCHAR(10),
    
    -- í™”ë©´ ì •ë³´
    screen_width INTEGER,
    screen_height INTEGER,
    screen_color_depth INTEGER,
    
    -- ì‹œìŠ¤í…œ ì •ë³´
    timezone VARCHAR(50),
    timezone_offset INTEGER,
    cpu_cores INTEGER,
    memory_gb INTEGER,
    
    -- ê¸°ëŠ¥ ì •ë³´
    touch_support BOOLEAN,
    max_touch_points INTEGER,
    
    -- ê´€ë¦¬ ì •ë³´
    device_nickname VARCHAR(100),
    first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    usage_count INTEGER DEFAULT 1,
    
    -- ìƒíƒœ
    is_blocked BOOLEAN DEFAULT FALSE,
    block_reason TEXT,
    blocked_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_device_last_seen ON device_info(last_seen);
CREATE INDEX idx_device_blocked ON device_info(is_blocked);
CREATE INDEX idx_device_usage ON device_info(usage_count DESC);
```

### attendance_records (ì¶œí‡´ê·¼ ê¸°ë¡)

```sql
CREATE TABLE attendance_records (
    id SERIAL PRIMARY KEY,
    
    -- ì§ì› ì •ë³´
    staff_id INTEGER NOT NULL,
    staff_name VARCHAR(50) NOT NULL,
    
    -- ì²´í¬ ì •ë³´
    check_type VARCHAR(10) NOT NULL CHECK (check_type IN ('in', 'out')),
    check_time TIMESTAMP NOT NULL,
    check_date DATE GENERATED ALWAYS AS (DATE(check_time)) STORED,
    
    -- ë””ë°”ì´ìŠ¤ ì •ë³´
    device_fingerprint VARCHAR(64) NOT NULL,
    
    -- QR í† í° ì •ë³´
    token_used VARCHAR(64) NOT NULL,
    token_expires_at TIMESTAMP,
    
    -- ìœ„ì¹˜ ì •ë³´ (ì„ íƒì )
    wifi_ssid VARCHAR(100),
    ip_address VARCHAR(45),
    gps_latitude DECIMAL(10, 8),
    gps_longitude DECIMAL(11, 8),
    
    -- ì‚¬ì§„ (ì„ íƒì )
    photo_path TEXT,
    
    -- í”Œë˜ê·¸
    is_suspicious BOOLEAN DEFAULT FALSE,
    is_late BOOLEAN DEFAULT FALSE,
    is_early_leave BOOLEAN DEFAULT FALSE,
    
    -- ì¶”ê°€ ì •ë³´
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (staff_id) REFERENCES staff(id),
    FOREIGN KEY (device_fingerprint) REFERENCES device_info(fingerprint)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_attendance_staff ON attendance_records(staff_id, check_date);
CREATE INDEX idx_attendance_date ON attendance_records(check_date);
CREATE INDEX idx_attendance_time ON attendance_records(check_time);
CREATE INDEX idx_attendance_type ON attendance_records(check_type);
CREATE INDEX idx_attendance_device ON attendance_records(device_fingerprint);
CREATE INDEX idx_attendance_suspicious ON attendance_records(is_suspicious, check_date);

-- ì¤‘ë³µ ë°©ì§€ (í•˜ë£¨ì— í•œ ë²ˆë§Œ ì¶œê·¼/í‡´ê·¼)
CREATE UNIQUE INDEX idx_attendance_unique_checkin 
ON attendance_records(staff_id, check_date, check_type)
WHERE check_type = 'in';

CREATE UNIQUE INDEX idx_attendance_unique_checkout 
ON attendance_records(staff_id, check_date, check_type)
WHERE check_type = 'out';
```

### suspicious_logs (ì˜ì‹¬ íŒ¨í„´ ë¡œê·¸)

```sql
CREATE TABLE suspicious_logs (
    id SERIAL PRIMARY KEY,
    detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- íŒ¨í„´ ì •ë³´
    pattern_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high')),
    
    -- ê´€ë ¨ ì •ë³´
    device_fingerprint VARCHAR(64),
    staff_ids JSONB,
    
    -- ìƒì„¸ ì •ë³´
    description TEXT NOT NULL,
    metadata JSONB,
    
    -- ê´€ë¦¬ì ì²˜ë¦¬
    admin_reviewed BOOLEAN DEFAULT FALSE,
    admin_notes TEXT,
    reviewed_at TIMESTAMP,
    reviewed_by VARCHAR(50),
    
    FOREIGN KEY (device_fingerprint) REFERENCES device_info(fingerprint)
);

CREATE INDEX idx_suspicious_reviewed ON suspicious_logs(admin_reviewed, detected_at);
CREATE INDEX idx_suspicious_severity ON suspicious_logs(severity, detected_at);
CREATE INDEX idx_suspicious_pattern ON suspicious_logs(pattern_type);
CREATE INDEX idx_suspicious_device ON suspicious_logs(device_fingerprint);
```

### qr_tokens (QR í† í°)

```sql
CREATE TABLE qr_tokens (
    id SERIAL PRIMARY KEY,
    token VARCHAR(64) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    used_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMP
);

CREATE INDEX idx_token_active ON qr_tokens(token, is_active, expires_at);
CREATE INDEX idx_token_expires ON qr_tokens(expires_at);

-- ìë™ ì •ë¦¬ íŠ¸ë¦¬ê±° (ë§Œë£Œëœ í† í° ë¹„í™œì„±í™”)
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE qr_tokens 
    SET is_active = FALSE 
    WHERE expires_at < NOW() AND is_active = TRUE;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_cleanup_tokens
AFTER INSERT ON qr_tokens
EXECUTE FUNCTION cleanup_expired_tokens();
```

### settings (ì‹œìŠ¤í…œ ì„¤ì •)

```sql
CREATE TABLE settings (
    id SERIAL PRIMARY KEY,
    key VARCHAR(100) UNIQUE NOT NULL,
    value TEXT NOT NULL,
    description TEXT,
    value_type VARCHAR(20) DEFAULT 'string',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_by VARCHAR(50)
);

-- ê¸°ë³¸ ì„¤ì •ê°’
INSERT INTO settings (key, value, description, value_type) VALUES
('qr_refresh_interval', '300', 'QR í† í° ê°±ì‹  ì£¼ê¸° (ì´ˆ)', 'integer'),
('checkin_start_time', '06:00', 'ì¶œê·¼ ì²´í¬ ì‹œì‘ ì‹œê°„', 'time'),
('checkin_end_time', '12:00', 'ì¶œê·¼ ì²´í¬ ì¢…ë£Œ ì‹œê°„', 'time'),
('checkout_start_time', '14:00', 'í‡´ê·¼ ì²´í¬ ì‹œì‘ ì‹œê°„', 'time'),
('checkout_end_time', '23:00', 'í‡´ê·¼ ì²´í¬ ì¢…ë£Œ ì‹œê°„', 'time'),
('late_threshold', '09:30', 'ì§€ê° ê¸°ì¤€ ì‹œê°„', 'time'),
('early_leave_threshold', '18:00', 'ì¡°í‡´ ê¸°ì¤€ ì‹œê°„', 'time'),
('enable_device_tracking', 'true', 'ë””ë°”ì´ìŠ¤ ì¶”ì  í™œì„±í™”', 'boolean'),
('enable_suspicious_detection', 'true', 'ì´ìƒ íŒ¨í„´ ê°ì§€ í™œì„±í™”', 'boolean'),
('consecutive_check_threshold', '3', 'ì—°ì† ì²´í¬ ê°ì§€ ì¸ì› ê¸°ì¤€', 'integer'),
('consecutive_check_minutes', '1', 'ì—°ì† ì²´í¬ ê°ì§€ ì‹œê°„ ê¸°ì¤€ (ë¶„)', 'integer');
```

---

# 3. QR í† í° ì‹œìŠ¤í…œ

## 3.1 í† í° ìƒì„± ë¡œì§

```python
import hashlib
import time
from datetime import datetime, timedelta

class QRTokenManager:
    """QR í† í° ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, secret_key: str, refresh_interval: int = 300):
        """
        Args:
            secret_key: í† í° ìƒì„±ìš© ë¹„ë°€í‚¤
            refresh_interval: ê°±ì‹  ì£¼ê¸° (ì´ˆ, ê¸°ë³¸ 5ë¶„)
        """
        self.secret_key = secret_key
        self.refresh_interval = refresh_interval
    
    def generate_token(self) -> dict:
        """
        ìƒˆ QR í† í° ìƒì„±
        
        Returns:
            {
                'token': str,
                'created_at': datetime,
                'expires_at': datetime,
                'url': str
            }
        """
        # í˜„ì¬ ì‹œê°„ì„ ê°±ì‹  ì£¼ê¸° ë‹¨ìœ„ë¡œ ë°˜ì˜¬ë¦¼
        timestamp = int(time.time() / self.refresh_interval)
        
        # í•´ì‹œ ìƒì„± (SHA-256)
        raw_string = f"{timestamp}{self.secret_key}"
        token = hashlib.sha256(raw_string.encode()).hexdigest()[:16]
        
        # ìƒì„± ë° ë§Œë£Œ ì‹œê°
        created_at = datetime.now()
        expires_at = created_at + timedelta(seconds=self.refresh_interval)
        
        # URL ìƒì„±
        base_url = "https://ê·¼íƒœ.ì—°ì„¸ë°”ë¡œì¹˜ê³¼.com/check"
        url = f"{base_url}?t={token}"
        
        return {
            'token': token,
            'created_at': created_at,
            'expires_at': expires_at,
            'url': url
        }
    
    def validate_token(self, token: str) -> dict:
        """
        í† í° ìœ íš¨ì„± ê²€ì¦
        
        Args:
            token: ê²€ì¦í•  í† í°
            
        Returns:
            {
                'valid': bool,
                'reason': str (ì‹¤íŒ¨ ì‹œ)
            }
        """
        # DBì—ì„œ í† í° ì¡°íšŒ
        db_token = self._get_token_from_db(token)
        
        if not db_token:
            return {
                'valid': False,
                'reason': 'TOKEN_NOT_FOUND'
            }
        
        # í™œì„± ìƒíƒœ í™•ì¸
        if not db_token['is_active']:
            return {
                'valid': False,
                'reason': 'TOKEN_INACTIVE'
            }
        
        # ë§Œë£Œ ì‹œê°„ í™•ì¸
        if datetime.now() > db_token['expires_at']:
            # í† í° ë¹„í™œì„±í™”
            self._deactivate_token(token)
            return {
                'valid': False,
                'reason': 'TOKEN_EXPIRED'
            }
        
        # ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
        self._increment_token_usage(token)
        
        return {
            'valid': True
        }
    
    def _get_token_from_db(self, token: str):
        """DBì—ì„œ í† í° ì¡°íšŒ (êµ¬í˜„ í•„ìš”)"""
        pass
    
    def _deactivate_token(self, token: str):
        """í† í° ë¹„í™œì„±í™” (êµ¬í˜„ í•„ìš”)"""
        pass
    
    def _increment_token_usage(self, token: str):
        """í† í° ì‚¬ìš© íšŸìˆ˜ ì¦ê°€ (êµ¬í˜„ í•„ìš”)"""
        pass


# ì‚¬ìš© ì˜ˆì‹œ
token_manager = QRTokenManager(
    secret_key="ë³‘ì›ë¹„ë°€í‚¤_ë³€ê²½í•˜ì„¸ìš”",
    refresh_interval=300  # 5ë¶„
)

# í† í° ìƒì„±
new_token = token_manager.generate_token()
print(f"Token: {new_token['token']}")
print(f"Expires: {new_token['expires_at']}")
print(f"URL: {new_token['url']}")

# í† í° ê²€ì¦
validation = token_manager.validate_token("abc123...")
if validation['valid']:
    print("í† í° ìœ íš¨")
else:
    print(f"í† í° ë¬´íš¨: {validation['reason']}")
```

---

## 3.2 ìë™ ê°±ì‹  ìŠ¤ì¼€ì¤„ëŸ¬

```python
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
import logging

class QRScheduler:
    """QR í† í° ìë™ ê°±ì‹  ìŠ¤ì¼€ì¤„ëŸ¬"""
    
    def __init__(self, token_manager: QRTokenManager):
        self.token_manager = token_manager
        self.scheduler = BackgroundScheduler()
        self.current_token = None
        self.logger = logging.getLogger(__name__)
    
    def start(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘"""
        # ì¦‰ì‹œ ì²« í† í° ìƒì„±
        self.refresh_token()
        
        # ì£¼ê¸°ì  ê°±ì‹  ì„¤ì •
        self.scheduler.add_job(
            func=self.refresh_token,
            trigger=IntervalTrigger(
                seconds=self.token_manager.refresh_interval
            ),
            id='qr_token_refresh',
            name='QR Token Refresh',
            replace_existing=True
        )
        
        self.scheduler.start()
        self.logger.info("QR í† í° ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ë¨")
    
    def stop(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€"""
        self.scheduler.shutdown()
        self.logger.info("QR í† í° ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€ë¨")
    
    def refresh_token(self):
        """í† í° ê°±ì‹ """
        try:
            # ìƒˆ í† í° ìƒì„±
            new_token = self.token_manager.generate_token()
            
            # DBì— ì €ì¥
            self._save_token_to_db(new_token)
            
            # í˜„ì¬ í† í° ì—…ë°ì´íŠ¸
            self.current_token = new_token
            
            # ì´ì „ í† í° ë¹„í™œì„±í™” (ì„ íƒì )
            self._deactivate_old_tokens()
            
            self.logger.info(
                f"QR í† í° ê°±ì‹  ì™„ë£Œ: {new_token['token']}, "
                f"ë§Œë£Œ: {new_token['expires_at']}"
            )
            
            return new_token
            
        except Exception as e:
            self.logger.error(f"í† í° ê°±ì‹  ì‹¤íŒ¨: {e}")
            raise
    
    def get_current_token(self) -> dict:
        """í˜„ì¬ ìœ íš¨í•œ í† í° ë°˜í™˜"""
        if not self.current_token:
            self.refresh_token()
        return self.current_token
    
    def _save_token_to_db(self, token_data: dict):
        """DBì— í† í° ì €ì¥ (êµ¬í˜„ í•„ìš”)"""
        pass
    
    def _deactivate_old_tokens(self):
        """ë§Œë£Œëœ í† í° ë¹„í™œì„±í™” (êµ¬í˜„ í•„ìš”)"""
        pass


# Flask ì• í”Œë¦¬ì¼€ì´ì…˜ì— í†µí•©
from flask import Flask

app = Flask(__name__)

# QR ìŠ¤ì¼€ì¤„ëŸ¬ ì´ˆê¸°í™”
token_manager = QRTokenManager(
    secret_key=app.config['SECRET_KEY'],
    refresh_interval=300
)
qr_scheduler = QRScheduler(token_manager)

# ì•± ì‹œì‘ ì‹œ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘
@app.before_first_request
def start_scheduler():
    qr_scheduler.start()

# ì•± ì¢…ë£Œ ì‹œ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€
import atexit
atexit.register(lambda: qr_scheduler.stop())

# QR ì½”ë“œ í‘œì‹œìš© ì—”ë“œí¬ì¸íŠ¸
@app.route('/api/qr/current', methods=['GET'])
def get_current_qr():
    """í˜„ì¬ ìœ íš¨í•œ QR í† í° ë°˜í™˜"""
    token = qr_scheduler.get_current_token()
    return jsonify({
        'token': token['token'],
        'url': token['url'],
        'expires_at': token['expires_at'].isoformat()
    })
```

---

# 4. ë””ë°”ì´ìŠ¤ í•‘ê±°í”„ë¦°íŒ…

## 4.1 í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì •ë³´ ìˆ˜ì§‘

```javascript
/**
 * ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘ (JavaScript)
 */

class DeviceFingerprint {
    /**
     * ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘
     */
    static async collect() {
        const info = {
            // ê¸°ë³¸ ì •ë³´
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            
            // í™”ë©´ ì •ë³´
            screenWidth: screen.width,
            screenHeight: screen.height,
            screenColorDepth: screen.colorDepth,
            screenAvailWidth: screen.availWidth,
            screenAvailHeight: screen.availHeight,
            
            // ì‹œê°„ëŒ€
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            timezoneOffset: new Date().getTimezoneOffset(),
            
            // í•˜ë“œì›¨ì–´
            cpuCores: navigator.hardwareConcurrency || 0,
            memory: navigator.deviceMemory || 0,
            
            // í„°ì¹˜ ì§€ì›
            touchSupport: 'ontouchstart' in window,
            maxTouchPoints: navigator.maxTouchPoints || 0,
            
            // ë°°í„°ë¦¬ (ì„ íƒì )
            battery: await this.getBatteryInfo(),
            
            // ë„¤íŠ¸ì›Œí¬
            connectionType: navigator.connection?.effectiveType || 'unknown',
            
            // Canvas í•‘ê±°í”„ë¦°íŠ¸
            canvasFingerprint: this.getCanvasFingerprint(),
            
            // WebGL í•‘ê±°í”„ë¦°íŠ¸
            webglFingerprint: this.getWebGLFingerprint()
        };
        
        // í•‘ê±°í”„ë¦°íŠ¸ ìƒì„±
        info.fingerprint = await this.generateFingerprint(info);
        
        return info;
    }
    
    /**
     * ë°°í„°ë¦¬ ì •ë³´ (ì„ íƒì )
     */
    static async getBatteryInfo() {
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                return {
                    level: battery.level,
                    charging: battery.charging
                };
            } catch (e) {
                return null;
            }
        }
        return null;
    }
    
    /**
     * Canvas í•‘ê±°í”„ë¦°íŠ¸
     */
    static getCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 200;
            canvas.height = 50;
            
            // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.textBaseline = 'alphabetic';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('Canvas Fingerprint ğŸ¦·', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Canvas Fingerprint ğŸ¦·', 4, 17);
            
            // ë°ì´í„° URLë¡œ ë³€í™˜
            const dataURL = canvas.toDataURL();
            
            // í•´ì‹œ ìƒì„±
            return this.simpleHash(dataURL);
        } catch (e) {
            return null;
        }
    }
    
    /**
     * WebGL í•‘ê±°í”„ë¦°íŠ¸
     */
    static getWebGLFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || 
                      canvas.getContext('experimental-webgl');
            
            if (!gl) return null;
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (!debugInfo) return null;
            
            return {
                vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
            };
        } catch (e) {
            return null;
        }
    }
    
    /**
     * í•‘ê±°í”„ë¦°íŠ¸ ìƒì„±
     */
    static async generateFingerprint(info) {
        const components = [
            info.userAgent,
            info.platform,
            info.language,
            info.screenWidth,
            info.screenHeight,
            info.screenColorDepth,
            info.timezone,
            info.timezoneOffset,
            info.cpuCores,
            info.memory,
            info.touchSupport,
            info.maxTouchPoints,
            info.canvasFingerprint,
            JSON.stringify(info.webglFingerprint)
        ];
        
        // ë¬¸ìì—´ë¡œ í•©ì¹˜ê¸°
        const raw = components.join('|');
        
        // SHA-256 í•´ì‹œ ìƒì„±
        const buffer = new TextEncoder().encode(raw);
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => 
            b.toString(16).padStart(2, '0')
        ).join('');
        
        return hashHex;
    }
    
    /**
     * ê°„ë‹¨í•œ í•´ì‹œ í•¨ìˆ˜
     */
    static simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return hash.toString(16);
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
async function collectAndSendDeviceInfo() {
    try {
        const deviceInfo = await DeviceFingerprint.collect();
        console.log('Device Fingerprint:', deviceInfo.fingerprint);
        
        // ì„œë²„ë¡œ ì „ì†¡
        return deviceInfo;
    } catch (error) {
        console.error('ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
        return null;
    }
}
```

---

## 4.2 ì„œë²„ ì¸¡ ë””ë°”ì´ìŠ¤ ê´€ë¦¬

```python
from sqlalchemy import func
from datetime import datetime

class DeviceManager:
    """ë””ë°”ì´ìŠ¤ ì •ë³´ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, db_session):
        self.db = db_session
    
    def save_or_update(self, device_info: dict) -> str:
        """
        ë””ë°”ì´ìŠ¤ ì •ë³´ ì €ì¥ ë˜ëŠ” ì—…ë°ì´íŠ¸
        
        Args:
            device_info: í´ë¼ì´ì–¸íŠ¸ì—ì„œ ìˆ˜ì§‘í•œ ë””ë°”ì´ìŠ¤ ì •ë³´
            
        Returns:
            fingerprint: ë””ë°”ì´ìŠ¤ í•‘ê±°í”„ë¦°íŠ¸
        """
        fingerprint = device_info['fingerprint']
        
        # ê¸°ì¡´ ë””ë°”ì´ìŠ¤ ì¡°íšŒ
        device = self.db.query(DeviceInfo).filter_by(
            fingerprint=fingerprint
        ).first()
        
        if device:
            # ì—…ë°ì´íŠ¸
            device.last_seen = datetime.now()
            device.usage_count += 1
            self.db.commit()
            
            return fingerprint
        else:
            # ì‹ ê·œ ë“±ë¡
            new_device = DeviceInfo(
                fingerprint=fingerprint,
                user_agent=device_info.get('userAgent'),
                platform=device_info.get('platform'),
                language=device_info.get('language'),
                screen_width=device_info.get('screenWidth'),
                screen_height=device_info.get('screenHeight'),
                screen_color_depth=device_info.get('screenColorDepth'),
                timezone=device_info.get('timezone'),
                timezone_offset=device_info.get('timezoneOffset'),
                cpu_cores=device_info.get('cpuCores'),
                memory_gb=device_info.get('memory'),
                touch_support=device_info.get('touchSupport'),
                max_touch_points=device_info.get('maxTouchPoints')
            )
            
            self.db.add(new_device)
            self.db.commit()
            
            return fingerprint
    
    def get_device(self, fingerprint: str):
        """ë””ë°”ì´ìŠ¤ ì •ë³´ ì¡°íšŒ"""
        return self.db.query(DeviceInfo).filter_by(
            fingerprint=fingerprint
        ).first()
    
    def is_blocked(self, fingerprint: str) -> bool:
        """ë””ë°”ì´ìŠ¤ ì°¨ë‹¨ ì—¬ë¶€ í™•ì¸"""
        device = self.get_device(fingerprint)
        return device.is_blocked if device else False
    
    def block_device(self, fingerprint: str, reason: str):
        """ë””ë°”ì´ìŠ¤ ì°¨ë‹¨"""
        device = self.get_device(fingerprint)
        if device:
            device.is_blocked = True
            device.block_reason = reason
            device.blocked_at = datetime.now()
            self.db.commit()
    
    def unblock_device(self, fingerprint: str):
        """ë””ë°”ì´ìŠ¤ ì°¨ë‹¨ í•´ì œ"""
        device = self.get_device(fingerprint)
        if device:
            device.is_blocked = False
            device.block_reason = None
            device.blocked_at = None
            self.db.commit()
    
    def get_device_stats(self, fingerprint: str) -> dict:
        """ë””ë°”ì´ìŠ¤ ì‚¬ìš© í†µê³„"""
        device = self.get_device(fingerprint)
        if not device:
            return None
        
        # ì´ ë””ë°”ì´ìŠ¤ë¡œ ì²´í¬í•œ ì§ì› í†µê³„
        staff_usage = self.db.query(
            AttendanceRecord.staff_id,
            AttendanceRecord.staff_name,
            func.count().label('count')
        ).filter_by(
            device_fingerprint=fingerprint
        ).group_by(
            AttendanceRecord.staff_id,
            AttendanceRecord.staff_name
        ).order_by(
            func.count().desc()
        ).all()
        
        return {
            'device_info': {
                'fingerprint': device.fingerprint,
                'nickname': device.device_nickname,
                'platform': device.platform,
                'first_seen': device.first_seen,
                'last_seen': device.last_seen,
                'usage_count': device.usage_count,
                'is_blocked': device.is_blocked
            },
            'staff_usage': [
                {
                    'staff_id': usage.staff_id,
                    'staff_name': usage.staff_name,
                    'count': usage.count
                }
                for usage in staff_usage
            ]
        }
```

---

# 5. ë³´ì•ˆ ê²€ì¦ ë¡œì§

## 5.1 ì¶œê·¼ ì²´í¬ ê²€ì¦ íë¦„

```python
from datetime import datetime, time
from typing import Dict, Tuple

class AttendanceValidator:
    """ì¶œí‡´ê·¼ ì²´í¬ ê²€ì¦ í´ë˜ìŠ¤"""
    
    def __init__(self, db_session, token_manager, device_manager):
        self.db = db_session
        self.token_manager = token_manager
        self.device_manager = device_manager
        self.settings = self._load_settings()
    
    def validate_checkin(
        self, 
        staff_id: int,
        token: str,
        device_info: dict
    ) -> Tuple[bool, str]:
        """
        ì¶œê·¼ ì²´í¬ ê²€ì¦
        
        Args:
            staff_id: ì§ì› ID
            token: QR í† í°
            device_info: ë””ë°”ì´ìŠ¤ ì •ë³´
            
        Returns:
            (success: bool, message: str)
        """
        # 1. í† í° ê²€ì¦
        token_valid = self.token_manager.validate_token(token)
        if not token_valid['valid']:
            return False, self._get_token_error_message(token_valid['reason'])
        
        # 2. ë””ë°”ì´ìŠ¤ ì°¨ë‹¨ í™•ì¸
        fingerprint = device_info['fingerprint']
        if self.device_manager.is_blocked(fingerprint):
            return False, "ì°¨ë‹¨ëœ ë””ë°”ì´ìŠ¤ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”."
        
        # 3. ì‹œê°„ëŒ€ ê²€ì¦
        time_valid, time_msg = self._validate_checkin_time()
        if not time_valid:
            return False, time_msg
        
        # 4. ì¤‘ë³µ ì²´í¬ ë°©ì§€
        duplicate, dup_msg = self._check_duplicate_checkin(staff_id)
        if duplicate:
            return False, dup_msg
        
        # 5. ì—°ì† ì²´í¬ ê°ì§€ (ê²½ê³ ë§Œ, ì°¨ë‹¨ ì•ˆí•¨)
        self._detect_consecutive_checks(fingerprint, staff_id)
        
        return True, "ê²€ì¦ ì™„ë£Œ"
    
    def _validate_checkin_time(self) -> Tuple[bool, str]:
        """ì¶œê·¼ ì²´í¬ ì‹œê°„ ê²€ì¦"""
        current_time = datetime.now().time()
        start_time = time.fromisoformat(self.settings['checkin_start_time'])
        end_time = time.fromisoformat(self.settings['checkin_end_time'])
        
        if not (start_time <= current_time <= end_time):
            return False, f"ì¶œê·¼ ì²´í¬ëŠ” {start_time.strftime('%H:%M')} ~ {end_time.strftime('%H:%M')} ì‚¬ì´ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."
        
        return True, ""
    
    def _check_duplicate_checkin(self, staff_id: int) -> Tuple[bool, str]:
        """ì¤‘ë³µ ì¶œê·¼ ì²´í¬ í™•ì¸"""
        today = datetime.now().date()
        
        existing = self.db.query(AttendanceRecord).filter(
            AttendanceRecord.staff_id == staff_id,
            AttendanceRecord.check_date == today,
            AttendanceRecord.check_type == 'in'
        ).first()
        
        if existing:
            time_str = existing.check_time.strftime('%H:%M')
            return True, f"ì˜¤ëŠ˜ ì´ë¯¸ ì¶œê·¼ ì²´í¬í•˜ì…¨ìŠµë‹ˆë‹¤ ({time_str})"
        
        return False, ""
    
    def _detect_consecutive_checks(self, fingerprint: str, staff_id: int):
        """ì—°ì† ì²´í¬ ê°ì§€"""
        threshold_minutes = int(self.settings['consecutive_check_minutes'])
        threshold_count = int(self.settings['consecutive_check_threshold'])
        
        # ìµœê·¼ Në¶„ ë‚´ ê°™ì€ ë””ë°”ì´ìŠ¤ë¡œ ì²´í¬í•œ ê¸°ë¡
        recent_time = datetime.now() - timedelta(minutes=threshold_minutes)
        
        recent_checks = self.db.query(AttendanceRecord).filter(
            AttendanceRecord.device_fingerprint == fingerprint,
            AttendanceRecord.check_time >= recent_time
        ).all()
        
        if len(recent_checks) >= threshold_count - 1:  # í˜„ì¬ ì²´í¬ í¬í•¨
            # ì˜ì‹¬ ë¡œê·¸ ìƒì„±
            self._create_suspicious_log(
                pattern_type='consecutive_checks',
                severity='high',
                device_fingerprint=fingerprint,
                staff_ids=[r.staff_id for r in recent_checks] + [staff_id],
                description=f"ë™ì¼ ë””ë°”ì´ìŠ¤ì—ì„œ {threshold_minutes}ë¶„ ë‚´ {len(recent_checks)+1}ëª… ì²´í¬"
            )
    
    def _get_token_error_message(self, reason: str) -> str:
        """í† í° ì˜¤ë¥˜ ë©”ì‹œì§€"""
        messages = {
            'TOKEN_NOT_FOUND': 'QR ì½”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
            'TOKEN_INACTIVE': 'QR ì½”ë“œê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.',
            'TOKEN_EXPIRED': 'QR ì½”ë“œê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ìŠ¤ìº”í•´ì£¼ì„¸ìš”.'
        }
        return messages.get(reason, 'QR ì½”ë“œ ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.')
    
    def _create_suspicious_log(
        self,
        pattern_type: str,
        severity: str,
        device_fingerprint: str,
        staff_ids: list,
        description: str
    ):
        """ì˜ì‹¬ ë¡œê·¸ ìƒì„± (êµ¬í˜„ í•„ìš”)"""
        pass
    
    def _load_settings(self) -> dict:
        """ì„¤ì • ë¡œë“œ (êµ¬í˜„ í•„ìš”)"""
        return {}
```

---

## 5.2 ì¶œê·¼ ì²´í¬ API

```python
from flask import Flask, request, jsonify
from datetime import datetime

app = Flask(__name__)

@app.route('/api/attendance/check-in', methods=['POST'])
def check_in():
    """ì¶œê·¼ ì²´í¬ API"""
    try:
        data = request.json
        
        # í•„ìˆ˜ íŒŒë¼ë¯¸í„° í™•ì¸
        required_fields = ['staff_id', 'token', 'device_info']
        for field in required_fields:
            if field not in data:
                return jsonify({
                    'success': False,
                    'error': f'í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëˆ„ë½: {field}'
                }), 400
        
        staff_id = data['staff_id']
        token = data['token']
        device_info = data['device_info']
        
        # ì§ì› ì •ë³´ í™•ì¸
        staff = get_staff_by_id(staff_id)
        if not staff:
            return jsonify({
                'success': False,
                'error': 'ì§ì› ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            }), 404
        
        # ë””ë°”ì´ìŠ¤ ì •ë³´ ì €ì¥/ì—…ë°ì´íŠ¸
        fingerprint = device_manager.save_or_update(device_info)
        
        # ê²€ì¦
        validator = AttendanceValidator(db.session, token_manager, device_manager)
        valid, message = validator.validate_checkin(staff_id, token, device_info)
        
        if not valid:
            return jsonify({
                'success': False,
                'error': message
            }), 400
        
        # ì§€ê° ì—¬ë¶€ í™•ì¸
        is_late = check_if_late(datetime.now().time())
        
        # ì¶œê·¼ ê¸°ë¡ ì €ì¥
        record = AttendanceRecord(
            staff_id=staff_id,
            staff_name=staff['name'],
            check_type='in',
            check_time=datetime.now(),
            device_fingerprint=fingerprint,
            token_used=token,
            wifi_ssid=device_info.get('wifi_ssid'),
            ip_address=request.remote_addr,
            is_late=is_late
        )
        
        db.session.add(record)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'ì¶œê·¼ ì²´í¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
            'data': {
                'staff_name': staff['name'],
                'check_time': record.check_time.isoformat(),
                'is_late': is_late
            }
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"ì¶œê·¼ ì²´í¬ ì˜¤ë¥˜: {e}")
        return jsonify({
            'success': False,
            'error': 'ì¶œê·¼ ì²´í¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
        }), 500


@app.route('/api/attendance/check-out', methods=['POST'])
def check_out():
    """í‡´ê·¼ ì²´í¬ API"""
    # ì¶œê·¼ ì²´í¬ì™€ ìœ ì‚¬í•œ ë¡œì§
    # check_type='out'ìœ¼ë¡œ ì„¤ì •
    pass


def check_if_late(check_time: time) -> bool:
    """ì§€ê° ì—¬ë¶€ í™•ì¸"""
    late_threshold = time.fromisoformat(
        get_setting('late_threshold', '09:30')
    )
    return check_time > late_threshold
```

---

# 6. ì´ìƒ íŒ¨í„´ ê°ì§€

## 6.1 íŒ¨í„´ ê°ì§€ ì‹œìŠ¤í…œ

```python
from datetime import datetime, timedelta
from sqlalchemy import and_, func

class SuspiciousPatternDetector:
    """ì´ìƒ íŒ¨í„´ ê°ì§€ ì‹œìŠ¤í…œ"""
    
    def __init__(self, db_session):
        self.db = db_session
        self.settings = self._load_settings()
    
    def detect_all_patterns(self, attendance_record: AttendanceRecord) -> list:
        """
        ëª¨ë“  ì´ìƒ íŒ¨í„´ ê°ì§€
        
        Args:
            attendance_record: ë°©ê¸ˆ ìƒì„±ëœ ì¶œí‡´ê·¼ ê¸°ë¡
            
        Returns:
            list of suspicious logs
        """
        patterns = []
        
        # íŒ¨í„´ 1: ì—°ì† ì²´í¬
        consecutive = self._detect_consecutive_checks(attendance_record)
        if consecutive:
            patterns.append(consecutive)
        
        # íŒ¨í„´ 2: ë¹„ì •ìƒ ì‹œê°„ëŒ€
        unusual_time = self._detect_unusual_time(attendance_record)
        if unusual_time:
            patterns.append(unusual_time)
        
        # íŒ¨í„´ 3: ì¤‘ë³µ ì²´í¬ ì‹œë„
        duplicate = self._detect_duplicate_attempts(attendance_record)
        if duplicate:
            patterns.append(duplicate)
        
        # íŒ¨í„´ 4: ê¸‰ê²©í•œ ìœ„ì¹˜ ë³€ê²½ (GPS ì‚¬ìš© ì‹œ)
        location_jump = self._detect_location_jump(attendance_record)
        if location_jump:
            patterns.append(location_jump)
        
        # ê°ì§€ëœ íŒ¨í„´ ì €ì¥
        for pattern in patterns:
            self._save_suspicious_log(pattern)
        
        return patterns
    
    def _detect_consecutive_checks(
        self, 
        record: AttendanceRecord
    ) -> dict:
        """
        ì—°ì† ì²´í¬ ê°ì§€
        
        ë™ì¼ ë””ë°”ì´ìŠ¤ë¡œ ì§§ì€ ì‹œê°„ ë‚´ ì—¬ëŸ¬ ëª… ì²´í¬
        """
        threshold_minutes = int(self.settings.get(
            'consecutive_check_minutes', 1
        ))
        threshold_count = int(self.settings.get(
            'consecutive_check_threshold', 3
        ))
        
        # ìµœê·¼ Në¶„ ë‚´ ê°™ì€ ë””ë°”ì´ìŠ¤ ì²´í¬
        recent_time = record.check_time - timedelta(
            minutes=threshold_minutes
        )
        
        recent_checks = self.db.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.device_fingerprint == record.device_fingerprint,
                AttendanceRecord.check_time >= recent_time,
                AttendanceRecord.id != record.id
            )
        ).all()
        
        if len(recent_checks) >= threshold_count - 1:
            staff_names = [r.staff_name for r in recent_checks] + [record.staff_name]
            
            return {
                'pattern_type': 'consecutive_checks',
                'severity': 'high',
                'device_fingerprint': record.device_fingerprint,
                'staff_ids': [r.staff_id for r in recent_checks] + [record.staff_id],
                'description': (
                    f"ë™ì¼ ë””ë°”ì´ìŠ¤ì—ì„œ {threshold_minutes}ë¶„ ë‚´ "
                    f"{len(recent_checks)+1}ëª… ì²´í¬\n"
                    f"ì§ì›: {', '.join(staff_names)}"
                ),
                'metadata': {
                    'time_window': threshold_minutes,
                    'check_count': len(recent_checks) + 1,
                    'staff_names': staff_names,
                    'check_times': [
                        r.check_time.isoformat() 
                        for r in recent_checks
                    ] + [record.check_time.isoformat()]
                }
            }
        
        return None
    
    def _detect_unusual_time(
        self, 
        record: AttendanceRecord
    ) -> dict:
        """
        ë¹„ì •ìƒ ì‹œê°„ëŒ€ ê°ì§€
        
        ìƒˆë²½ì´ë‚˜ ì‹¬ì•¼ ì‹œê°„ ì²´í¬
        """
        check_hour = record.check_time.hour
        
        # ìƒˆë²½ (02:00 ~ 05:00)
        if 2 <= check_hour < 5:
            return {
                'pattern_type': 'unusual_time_dawn',
                'severity': 'medium',
                'device_fingerprint': record.device_fingerprint,
                'staff_ids': [record.staff_id],
                'description': (
                    f"ë¹„ì •ìƒì ì¸ ì‹œê°„ëŒ€ ì²´í¬ (ìƒˆë²½ {check_hour:02d}ì‹œ)\n"
                    f"ì§ì›: {record.staff_name}"
                ),
                'metadata': {
                    'check_hour': check_hour,
                    'check_time': record.check_time.isoformat()
                }
            }
        
        # ì‹¬ì•¼ (23:00 ~ 02:00)
        elif check_hour >= 23 or check_hour < 2:
            return {
                'pattern_type': 'unusual_time_night',
                'severity': 'low',
                'device_fingerprint': record.device_fingerprint,
                'staff_ids': [record.staff_id],
                'description': (
                    f"ëŠ¦ì€ ì‹œê°„ ì²´í¬ (ì‹¬ì•¼ {check_hour:02d}ì‹œ)\n"
                    f"ì§ì›: {record.staff_name}"
                ),
                'metadata': {
                    'check_hour': check_hour,
                    'check_time': record.check_time.isoformat()
                }
            }
        
        return None
    
    def _detect_duplicate_attempts(
        self, 
        record: AttendanceRecord
    ) -> dict:
        """
        ì¤‘ë³µ ì²´í¬ ì‹œë„ ê°ì§€
        
        í•˜ë£¨ì— ì—¬ëŸ¬ ë²ˆ ì¶œê·¼/í‡´ê·¼ ì‹œë„
        """
        today = record.check_date
        
        # ì˜¤ëŠ˜ ê°™ì€ íƒ€ì… ì²´í¬ ê°œìˆ˜
        same_type_count = self.db.query(
            func.count(AttendanceRecord.id)
        ).filter(
            and_(
                AttendanceRecord.staff_id == record.staff_id,
                AttendanceRecord.check_date == today,
                AttendanceRecord.check_type == record.check_type,
                AttendanceRecord.id != record.id
            )
        ).scalar()
        
        if same_type_count > 0:
            check_type_kr = 'ì¶œê·¼' if record.check_type == 'in' else 'í‡´ê·¼'
            
            return {
                'pattern_type': 'duplicate_attempt',
                'severity': 'high',
                'device_fingerprint': record.device_fingerprint,
                'staff_ids': [record.staff_id],
                'description': (
                    f"í•˜ë£¨ì— {same_type_count + 1}íšŒ {check_type_kr} ì²´í¬ ì‹œë„\n"
                    f"ì§ì›: {record.staff_name}"
                ),
                'metadata': {
                    'check_type': record.check_type,
                    'attempt_count': same_type_count + 1,
                    'date': today.isoformat()
                }
            }
        
        return None
    
    def _detect_location_jump(
        self, 
        record: AttendanceRecord
    ) -> dict:
        """
        ê¸‰ê²©í•œ ìœ„ì¹˜ ë³€ê²½ ê°ì§€ (GPS ì‚¬ìš© ì‹œ)
        
        ì§§ì€ ì‹œê°„ ë‚´ ë¨¼ ê±°ë¦¬ ì´ë™
        """
        if not (record.gps_latitude and record.gps_longitude):
            return None
        
        # ìµœê·¼ 1ì‹œê°„ ë‚´ ê°™ì€ ì§ì›ì˜ ë§ˆì§€ë§‰ ì²´í¬
        recent_time = record.check_time - timedelta(hours=1)
        
        last_record = self.db.query(AttendanceRecord).filter(
            and_(
                AttendanceRecord.staff_id == record.staff_id,
                AttendanceRecord.check_time >= recent_time,
                AttendanceRecord.check_time < record.check_time,
                AttendanceRecord.gps_latitude.isnot(None)
            )
        ).order_by(
            AttendanceRecord.check_time.desc()
        ).first()
        
        if last_record:
            # ê±°ë¦¬ ê³„ì‚° (ê°„ë‹¨í•œ ì§ì„  ê±°ë¦¬, ì‹¤ì œë¡œëŠ” haversine ì‚¬ìš©)
            distance_km = self._calculate_distance(
                last_record.gps_latitude,
                last_record.gps_longitude,
                record.gps_latitude,
                record.gps_longitude
            )
            
            time_diff_minutes = (
                record.check_time - last_record.check_time
            ).total_seconds() / 60
            
            # 1ì‹œê°„ ë‚´ 10km ì´ìƒ ì´ë™ (ì¡°ì • ê°€ëŠ¥)
            if distance_km > 10:
                return {
                    'pattern_type': 'location_jump',
                    'severity': 'medium',
                    'device_fingerprint': record.device_fingerprint,
                    'staff_ids': [record.staff_id],
                    'description': (
                        f"ì§§ì€ ì‹œê°„ ë‚´ ë¨¼ ê±°ë¦¬ ì´ë™\n"
                        f"ì§ì›: {record.staff_name}\n"
                        f"ê±°ë¦¬: {distance_km:.1f}km\n"
                        f"ì‹œê°„: {time_diff_minutes:.0f}ë¶„"
                    ),
                    'metadata': {
                        'distance_km': distance_km,
                        'time_diff_minutes': time_diff_minutes,
                        'from': {
                            'lat': float(last_record.gps_latitude),
                            'lng': float(last_record.gps_longitude),
                            'time': last_record.check_time.isoformat()
                        },
                        'to': {
                            'lat': float(record.gps_latitude),
                            'lng': float(record.gps_longitude),
                            'time': record.check_time.isoformat()
                        }
                    }
                }
        
        return None
    
    def _calculate_distance(
        self, 
        lat1: float, 
        lon1: float, 
        lat2: float, 
        lon2: float
    ) -> float:
        """
        ë‘ ì§€ì  ê°„ ê±°ë¦¬ ê³„ì‚° (Haversine ê³µì‹)
        
        Returns:
            ê±°ë¦¬ (km)
        """
        from math import radians, cos, sin, asin, sqrt
        
        # ë¼ë””ì•ˆìœ¼ë¡œ ë³€í™˜
        lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
        
        # Haversine ê³µì‹
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        
        # ì§€êµ¬ ë°˜ì§€ë¦„ (km)
        r = 6371
        
        return c * r
    
    def _save_suspicious_log(self, pattern: dict):
        """ì˜ì‹¬ ë¡œê·¸ ì €ì¥"""
        log = SuspiciousLog(
            pattern_type=pattern['pattern_type'],
            severity=pattern['severity'],
            device_fingerprint=pattern['device_fingerprint'],
            staff_ids=pattern['staff_ids'],
            description=pattern['description'],
            metadata=pattern.get('metadata')
        )
        
        self.db.add(log)
        self.db.commit()
        
        # ê´€ë¦¬ì ì•Œë¦¼ ì „ì†¡
        self._send_admin_notification(log)
    
    def _send_admin_notification(self, log: SuspiciousLog):
        """ê´€ë¦¬ì ì•Œë¦¼ ì „ì†¡ (êµ¬í˜„ í•„ìš”)"""
        pass
    
    def _load_settings(self) -> dict:
        """ì„¤ì • ë¡œë“œ (êµ¬í˜„ í•„ìš”)"""
        return {}
```

---

# 7. API ëª…ì„¸

## 7.1 API ì—”ë“œí¬ì¸íŠ¸ ëª©ë¡

```
# QR ê´€ë ¨
GET  /api/qr/current              # í˜„ì¬ ìœ íš¨í•œ QR í† í° ì¡°íšŒ
GET  /api/qr/display              # QR ì½”ë“œ í‘œì‹œ í˜ì´ì§€

# ì¶œí‡´ê·¼ ì²´í¬
POST /api/attendance/check-in     # ì¶œê·¼ ì²´í¬
POST /api/attendance/check-out    # í‡´ê·¼ ì²´í¬

# ì¡°íšŒ
GET  /api/attendance/records      # ì¶œí‡´ê·¼ ê¸°ë¡ ì¡°íšŒ
GET  /api/attendance/today        # ì˜¤ëŠ˜ ì¶œí‡´ê·¼ í˜„í™©
GET  /api/attendance/staff/:id    # íŠ¹ì • ì§ì› ê¸°ë¡

# í†µê³„
GET  /api/stats/daily             # ì¼ê°„ í†µê³„
GET  /api/stats/monthly           # ì›”ê°„ í†µê³„
GET  /api/stats/staff/:id         # ì§ì›ë³„ í†µê³„

# ë””ë°”ì´ìŠ¤ ê´€ë¦¬
GET  /api/devices                 # ë””ë°”ì´ìŠ¤ ëª©ë¡
GET  /api/devices/:fingerprint    # ë””ë°”ì´ìŠ¤ ìƒì„¸
PUT  /api/devices/:fingerprint    # ë””ë°”ì´ìŠ¤ ìˆ˜ì •
POST /api/devices/:fingerprint/block   # ë””ë°”ì´ìŠ¤ ì°¨ë‹¨
POST /api/devices/:fingerprint/unblock # ë””ë°”ì´ìŠ¤ ì°¨ë‹¨ í•´ì œ

# ì˜ì‹¬ íŒ¨í„´
GET  /api/suspicious/logs         # ì˜ì‹¬ íŒ¨í„´ ë¡œê·¸ ì¡°íšŒ
PUT  /api/suspicious/:id/review   # ë¡œê·¸ ê²€í†  ì™„ë£Œ ì²˜ë¦¬

# ì„¤ì •
GET  /api/settings                # ì„¤ì • ì¡°íšŒ
PUT  /api/settings                # ì„¤ì • ë³€ê²½
```

---

## 7.2 API ìƒì„¸ ëª…ì„¸

### POST /api/attendance/check-in

ì¶œê·¼ ì²´í¬

**Request:**
```json
{
  "staff_id": 1,
  "token": "abc123def456",
  "device_info": {
    "fingerprint": "a7f3c8e9d2b1f4a6c3e7d8b2f1a9c4e6",
    "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X)...",
    "platform": "iPhone",
    "language": "ko-KR",
    "screenWidth": 390,
    "screenHeight": 844,
    "screenColorDepth": 24,
    "timezone": "Asia/Seoul",
    "timezoneOffset": -540,
    "cpuCores": 6,
    "memory": 4,
    "touchSupport": true,
    "maxTouchPoints": 5
  },
  "wifi_ssid": "ë³‘ì›WiFi",
  "gps": {
    "latitude": 37.5665,
    "longitude": 126.9780
  }
}
```

**Response (ì„±ê³µ):**
```json
{
  "success": true,
  "message": "ì¶œê·¼ ì²´í¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
  "data": {
    "record_id": 1234,
    "staff_name": "ê¹€ìœ ì§„",
    "check_time": "2025-01-20T09:05:23+09:00",
    "is_late": false
  }
}
```

**Response (ì‹¤íŒ¨):**
```json
{
  "success": false,
  "error": "QR ì½”ë“œê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ìŠ¤ìº”í•´ì£¼ì„¸ìš”."
}
```

**Status Codes:**
- 200: ì„±ê³µ
- 400: ê²€ì¦ ì‹¤íŒ¨ (í† í° ë§Œë£Œ, ì¤‘ë³µ ì²´í¬ ë“±)
- 404: ì§ì› ì—†ìŒ
- 500: ì„œë²„ ì˜¤ë¥˜

---

### GET /api/attendance/records

ì¶œí‡´ê·¼ ê¸°ë¡ ì¡°íšŒ

**Query Parameters:**
- `staff_id` (optional): ì§ì› ID
- `start_date` (optional): ì‹œì‘ ë‚ ì§œ (YYYY-MM-DD)
- `end_date` (optional): ì¢…ë£Œ ë‚ ì§œ (YYYY-MM-DD)
- `check_type` (optional): 'in' or 'out'
- `page` (optional): í˜ì´ì§€ ë²ˆí˜¸ (ê¸°ë³¸ 1)
- `per_page` (optional): í˜ì´ì§€ë‹¹ ê°œìˆ˜ (ê¸°ë³¸ 50)

**Request:**
```
GET /api/attendance/records?staff_id=1&start_date=2025-01-01&end_date=2025-01-31
```

**Response:**
```json
{
  "success": true,
  "data": {
    "records": [
      {
        "id": 1234,
        "staff_id": 1,
        "staff_name": "ê¹€ìœ ì§„",
        "check_type": "in",
        "check_time": "2025-01-20T09:05:23+09:00",
        "device_nickname": "ì ‘ìˆ˜ íƒœë¸”ë¦¿",
        "is_late": false,
        "is_suspicious": false
      },
      {
        "id": 1235,
        "staff_id": 1,
        "staff_name": "ê¹€ìœ ì§„",
        "check_type": "out",
        "check_time": "2025-01-20T18:45:12+09:00",
        "device_nickname": "ì ‘ìˆ˜ íƒœë¸”ë¦¿",
        "is_early_leave": false,
        "is_suspicious": false
      }
    ],
    "pagination": {
      "page": 1,
      "per_page": 50,
      "total": 42,
      "total_pages": 1
    }
  }
}
```

---

### GET /api/attendance/today

ì˜¤ëŠ˜ ì¶œí‡´ê·¼ í˜„í™©

**Response:**
```json
{
  "success": true,
  "data": {
    "date": "2025-01-20",
    "total_staff": 20,
    "checked_in": 18,
    "checked_out": 5,
    "late_count": 2,
    "missing": [
      {
        "staff_id": 15,
        "staff_name": "í™ê¸¸ë™",
        "position": "ì €ë…„ì°¨"
      },
      {
        "staff_id": 19,
        "staff_name": "ê¹€ì² ìˆ˜",
        "position": "ì¤‘ë…„ì°¨"
      }
    ],
    "late_staff": [
      {
        "staff_id": 3,
        "staff_name": "ë°•ì§€ë¯¼",
        "check_time": "2025-01-20T09:35:23+09:00",
        "minutes_late": 5
      }
    ],
    "recent_checks": [
      {
        "staff_name": "ê¹€ìœ ì§„",
        "check_type": "in",
        "check_time": "2025-01-20T09:05:23+09:00"
      },
      {
        "staff_name": "ì´ì†Œì˜",
        "check_type": "in",
        "check_time": "2025-01-20T09:07:45+09:00"
      }
    ]
  }
}
```

---

### GET /api/stats/monthly

ì›”ê°„ í†µê³„

**Query Parameters:**
- `year`: ë…„ë„ (í•„ìˆ˜)
- `month`: ì›” (í•„ìˆ˜)
- `staff_id` (optional): íŠ¹ì • ì§ì›ë§Œ ì¡°íšŒ

**Request:**
```
GET /api/stats/monthly?year=2025&month=1
```

**Response:**
```json
{
  "success": true,
  "data": {
    "year": 2025,
    "month": 1,
    "total_staff": 20,
    "work_days": 22,
    "overall": {
      "total_checkins": 433,
      "total_checkouts": 408,
      "checkin_rate": 98.5,
      "checkout_rate": 94.2,
      "average_checkin_time": "09:08:35",
      "average_checkout_time": "18:43:21",
      "average_work_hours": "9:35:00",
      "late_count": 3,
      "early_leave_count": 5
    },
    "by_staff": [
      {
        "staff_id": 1,
        "staff_name": "ê¹€ìœ ì§„",
        "work_days": 18,
        "late_count": 1,
        "early_leave_count": 0,
        "average_checkin": "09:05:12",
        "average_checkout": "18:50:23",
        "average_work_hours": "9:45:00"
      }
    ],
    "daily_stats": [
      {
        "date": "2025-01-20",
        "checkin_count": 19,
        "checkout_count": 18,
        "late_count": 1
      }
    ]
  }
}
```

---

### GET /api/devices

ë””ë°”ì´ìŠ¤ ëª©ë¡

**Query Parameters:**
- `blocked` (optional): true/false
- `sort` (optional): 'usage' or 'last_seen'

**Response:**
```json
{
  "success": true,
  "data": {
    "devices": [
      {
        "fingerprint": "a7f3c8e9d2b1f4a6c3e7d8b2f1a9c4e6",
        "nickname": "ì ‘ìˆ˜ íƒœë¸”ë¦¿",
        "platform": "iPad",
        "first_seen": "2025-01-15T10:00:00+09:00",
        "last_seen": "2025-01-20T09:15:23+09:00",
        "usage_count": 127,
        "is_blocked": false,
        "top_users": [
          {
            "staff_name": "ê¹€ìœ ì§„",
            "count": 42
          },
          {
            "staff_name": "ì´ì†Œì˜",
            "count": 38
          }
        ]
      }
    ],
    "total": 8
  }
}
```

---

### GET /api/suspicious/logs

ì˜ì‹¬ íŒ¨í„´ ë¡œê·¸ ì¡°íšŒ

**Query Parameters:**
- `reviewed` (optional): true/false
- `severity` (optional): 'low', 'medium', 'high'
- `start_date` (optional): YYYY-MM-DD
- `end_date` (optional): YYYY-MM-DD

**Response:**
```json
{
  "success": true,
  "data": {
    "logs": [
      {
        "id": 123,
        "detected_at": "2025-01-20T09:15:45+09:00",
        "pattern_type": "consecutive_checks",
        "severity": "high",
        "description": "ë™ì¼ ë””ë°”ì´ìŠ¤ì—ì„œ 1ë¶„ ë‚´ 3ëª… ì²´í¬\nì§ì›: ê¹€ìœ ì§„, ì´ì†Œì˜, ë°•ì§€ë¯¼",
        "device_nickname": "ì ‘ìˆ˜ íƒœë¸”ë¦¿",
        "staff_names": ["ê¹€ìœ ì§„", "ì´ì†Œì˜", "ë°•ì§€ë¯¼"],
        "admin_reviewed": false
      }
    ],
    "unreviewed_count": 5,
    "total": 23
  }
}
```

---

### PUT /api/suspicious/:id/review

ì˜ì‹¬ ë¡œê·¸ ê²€í†  ì™„ë£Œ ì²˜ë¦¬

**Request:**
```json
{
  "action": "normal",  // 'normal', 'warning', 'ignore'
  "notes": "ê°™ì´ ë„ì°©í•´ì„œ ìˆœì„œëŒ€ë¡œ ì²´í¬í•œ ê²ƒìœ¼ë¡œ í™•ì¸ë¨"
}
```

**Response:**
```json
{
  "success": true,
  "message": "ê²€í† ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
}
```

---

# 8. í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„

## 8.1 ì¶œí‡´ê·¼ ì²´í¬ í˜ì´ì§€

```javascript
// AttendanceCheckPage.jsx (React)

import React, { useState, useEffect } from 'react';
import axios from 'axios';
import DeviceFingerprint from './DeviceFingerprint';

function AttendanceCheckPage() {
    const [staffList, setStaffList] = useState([]);
    const [selectedStaff, setSelectedStaff] = useState('');
    const [token, setToken] = useState('');
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState({ type: '', text: '' });
    
    useEffect(() => {
        // URLì—ì„œ í† í° ì¶”ì¶œ
        const params = new URLSearchParams(window.location.search);
        const t = params.get('t');
        
        if (!t) {
            setMessage({
                type: 'error',
                text: 'QR ì½”ë“œë¥¼ ë‹¤ì‹œ ìŠ¤ìº”í•´ì£¼ì„¸ìš”.'
            });
            return;
        }
        
        setToken(t);
        
        // ì§ì› ëª©ë¡ ë¡œë“œ
        loadStaffList();
    }, []);
    
    const loadStaffList = async () => {
        try {
            const response = await axios.get('/api/staff');
            setStaffList(response.data.data);
        } catch (error) {
            console.error('ì§ì› ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', error);
        }
    };
    
    const handleCheckIn = async () => {
        if (!selectedStaff) {
            setMessage({
                type: 'error',
                text: 'ì§ì›ì„ ì„ íƒí•´ì£¼ì„¸ìš”.'
            });
            return;
        }
        
        setLoading(true);
        setMessage({ type: '', text: '' });
        
        try {
            // ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘
            const deviceInfo = await DeviceFingerprint.collect();
            
            // API í˜¸ì¶œ
            const response = await axios.post('/api/attendance/check-in', {
                staff_id: selectedStaff,
                token: token,
                device_info: deviceInfo
            });
            
            // ì„±ê³µ
            setMessage({
                type: 'success',
                text: response.data.message
            });
            
            // ì§ì› ì„ íƒ ì´ˆê¸°í™”
            setSelectedStaff('');
            
        } catch (error) {
            // ì‹¤íŒ¨
            const errorMsg = error.response?.data?.error || 
                           'ì¶œê·¼ ì²´í¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
            setMessage({
                type: 'error',
                text: errorMsg
            });
        } finally {
            setLoading(false);
        }
    };
    
    const handleCheckOut = async () => {
        // í‡´ê·¼ ì²´í¬ (ì¶œê·¼ê³¼ ìœ ì‚¬)
        // /api/attendance/check-out í˜¸ì¶œ
    };
    
    return (
        <div className="attendance-check-container">
            <div className="header">
                <h1>ğŸ¦· ì—°ì„¸ë°”ë¡œì¹˜ê³¼</h1>
                <h2>ì¶œí‡´ê·¼ ì²´í¬</h2>
            </div>
            
            {message.text && (
                <div className={`message ${message.type}`}>
                    {message.text}
                </div>
            )}
            
            <div className="form-group">
                <label>ì§ì› ì„ íƒ</label>
                <select 
                    value={selectedStaff} 
                    onChange={(e) => setSelectedStaff(e.target.value)}
                    disabled={loading}
                >
                    <option value="">ì„ íƒí•˜ì„¸ìš”</option>
                    {staffList.map(staff => (
                        <option key={staff.id} value={staff.id}>
                            {staff.name} ({staff.position})
                        </option>
                    ))}
                </select>
            </div>
            
            <div className="button-group">
                <button 
                    className="btn-checkin"
                    onClick={handleCheckIn}
                    disabled={loading || !selectedStaff}
                >
                    {loading ? 'ì²˜ë¦¬ ì¤‘...' : 'ğŸ¢ ì¶œê·¼'}
                </button>
                
                <button 
                    className="btn-checkout"
                    onClick={handleCheckOut}
                    disabled={loading || !selectedStaff}
                >
                    {loading ? 'ì²˜ë¦¬ ì¤‘...' : 'ğŸ  í‡´ê·¼'}
                </button>
            </div>
            
            <div className="info">
                <p>ğŸ’¡ ì´ë¦„ì„ ì„ íƒí•œ í›„ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</p>
            </div>
        </div>
    );
}

export default AttendanceCheckPage;
```

---

## 8.2 QR ì½”ë“œ í‘œì‹œ í˜ì´ì§€

```javascript
// QRDisplayPage.jsx (React)

import React, { useState, useEffect } from 'react';
import QRCode from 'qrcode';
import axios from 'axios';

function QRDisplayPage() {
    const [qrUrl, setQrUrl] = useState('');
    const [qrImage, setQrImage] = useState('');
    const [expiresAt, setExpiresAt] = useState(null);
    const [countdown, setCountdown] = useState(0);
    
    useEffect(() => {
        // ì²« QR ë¡œë“œ
        refreshQR();
        
        // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´ ì—…ë°ì´íŠ¸
        const countdownTimer = setInterval(updateCountdown, 1000);
        
        return () => {
            clearInterval(countdownTimer);
        };
    }, []);
    
    useEffect(() => {
        // ë§Œë£Œ 5ì´ˆ ì „ì— ë¯¸ë¦¬ ê°±ì‹ 
        if (countdown <= 5 && countdown > 0) {
            refreshQR();
        }
    }, [countdown]);
    
    const refreshQR = async () => {
        try {
            // í˜„ì¬ QR í† í° ê°€ì ¸ì˜¤ê¸°
            const response = await axios.get('/api/qr/current');
            const data = response.data;
            
            setQrUrl(data.url);
            setExpiresAt(new Date(data.expires_at));
            
            // QR ì´ë¯¸ì§€ ìƒì„±
            const qrDataUrl = await QRCode.toDataURL(data.url, {
                width: 300,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#FFFFFF'
                }
            });
            
            setQrImage(qrDataUrl);
            
        } catch (error) {
            console.error('QR ë¡œë“œ ì‹¤íŒ¨:', error);
        }
    };
    
    const updateCountdown = () => {
        if (expiresAt) {
            const now = new Date();
            const diff = Math.max(0, Math.floor((expiresAt - now) / 1000));
            setCountdown(diff);
        }
    };
    
    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };
    
    return (
        <div className="qr-display-container">
            <div className="header">
                <h1>ğŸ¦· ì—°ì„¸ë°”ë¡œì¹˜ê³¼</h1>
                <h2>ì¶œí‡´ê·¼ QR ì½”ë“œ</h2>
            </div>
            
            <div className="qr-code-wrapper">
                {qrImage ? (
                    <img 
                        src={qrImage} 
                        alt="ì¶œí‡´ê·¼ QR ì½”ë“œ"
                        className="qr-code"
                    />
                ) : (
                    <div className="loading">ë¡œë”© ì¤‘...</div>
                )}
            </div>
            
            <div className="info-panel">
                <div className="countdown">
                    <span className="label">ê°±ì‹ ê¹Œì§€</span>
                    <span className="time">{formatTime(countdown)}</span>
                </div>
                
                <div className="instructions">
                    <p>ğŸ“± ìŠ¤ë§ˆíŠ¸í° ì¹´ë©”ë¼ë¡œ ìŠ¤ìº”í•˜ì„¸ìš”</p>
                    <p>â° 5ë¶„ë§ˆë‹¤ ìë™ ê°±ì‹ ë©ë‹ˆë‹¤</p>
                </div>
            </div>
            
            <div className="status-bar">
                <span className={countdown <= 10 ? 'warning' : 'normal'}>
                    {countdown <= 10 ? 'âš ï¸ ê³§ ê°±ì‹ ë©ë‹ˆë‹¤' : 'âœ… ì •ìƒ'}
                </span>
            </div>
        </div>
    );
}

export default QRDisplayPage;
```

---

## 8.3 ê´€ë¦¬ì ëŒ€ì‹œë³´ë“œ

```javascript
// AdminDashboard.jsx (React)

import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { format } from 'date-fns';

function AdminDashboard() {
    const [todayStats, setTodayStats] = useState(null);
    const [suspiciousLogs, setSuspiciousLogs] = useState([]);
    const [recentChecks, setRecentChecks] = useState([]);
    
    useEffect(() => {
        loadDashboardData();
        
        // 30ì´ˆë§ˆë‹¤ ìë™ ê°±ì‹ 
        const interval = setInterval(loadDashboardData, 30000);
        
        return () => clearInterval(interval);
    }, []);
    
    const loadDashboardData = async () => {
        try {
            // ì˜¤ëŠ˜ í˜„í™©
            const todayResponse = await axios.get('/api/attendance/today');
            setTodayStats(todayResponse.data.data);
            setRecentChecks(todayResponse.data.data.recent_checks);
            
            // ì˜ì‹¬ ë¡œê·¸
            const logsResponse = await axios.get('/api/suspicious/logs', {
                params: { reviewed: false }
            });
            setSuspiciousLogs(logsResponse.data.data.logs);
            
        } catch (error) {
            console.error('ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
        }
    };
    
    const handleReviewLog = async (logId, action, notes) => {
        try {
            await axios.put(`/api/suspicious/${logId}/review`, {
                action,
                notes
            });
            
            // ëª©ë¡ ê°±ì‹ 
            loadDashboardData();
            
        } catch (error) {
            console.error('ê²€í†  ì²˜ë¦¬ ì‹¤íŒ¨:', error);
        }
    };
    
    if (!todayStats) {
        return <div>ë¡œë”© ì¤‘...</div>;
    }
    
    const checkinRate = (todayStats.checked_in / todayStats.total_staff * 100).toFixed(1);
    
    return (
        <div className="admin-dashboard">
            <div className="header">
                <h1>ğŸ“Š ì¶œí‡´ê·¼ í˜„í™©</h1>
                <div className="date">
                    {format(new Date(), 'yyyyë…„ MMì›” ddì¼ (EEE)', { locale: ko })}
                </div>
            </div>
            
            {/* ì˜¤ëŠ˜ í˜„í™© */}
            <div className="stats-panel">
                <div className="stat-card">
                    <div className="stat-title">ì¶œê·¼ ì™„ë£Œ</div>
                    <div className="stat-value">
                        {todayStats.checked_in} / {todayStats.total_staff}
                    </div>
                    <div className="stat-progress">
                        <div 
                            className="progress-bar"
                            style={{ width: `${checkinRate}%` }}
                        ></div>
                    </div>
                    <div className="stat-subtitle">{checkinRate}%</div>
                </div>
                
                <div className="stat-card">
                    <div className="stat-title">í‡´ê·¼ ì™„ë£Œ</div>
                    <div className="stat-value">{todayStats.checked_out}</div>
                </div>
                
                <div className="stat-card warning">
                    <div className="stat-title">ì§€ê°</div>
                    <div className="stat-value">{todayStats.late_count}</div>
                </div>
                
                <div className="stat-card error">
                    <div className="stat-title">ë¯¸ì¶œê·¼</div>
                    <div className="stat-value">
                        {todayStats.total_staff - todayStats.checked_in}
                    </div>
                </div>
            </div>
            
            {/* ì˜ì‹¬ íŒ¨í„´ ì•Œë¦¼ */}
            {suspiciousLogs.length > 0 && (
                <div className="suspicious-panel">
                    <h2>âš ï¸ ì˜ì‹¬ íŒ¨í„´ ê°ì§€ ({suspiciousLogs.length}ê±´)</h2>
                    
                    {suspiciousLogs.map(log => (
                        <div key={log.id} className={`log-card ${log.severity}`}>
                            <div className="log-header">
                                <span className="severity">{log.severity.toUpperCase()}</span>
                                <span className="time">
                                    {format(new Date(log.detected_at), 'HH:mm:ss')}
                                </span>
                            </div>
                            
                            <div className="log-description">
                                {log.description}
                            </div>
                            
                            <div className="log-actions">
                                <button 
                                    className="btn-normal"
                                    onClick={() => handleReviewLog(log.id, 'normal', 'ì •ìƒ í™•ì¸ë¨')}
                                >
                                    ì •ìƒ ì²˜ë¦¬
                                </button>
                                <button 
                                    className="btn-warning"
                                    onClick={() => handleReviewLog(log.id, 'warning', 'ê²½ê³  ë°œì†¡')}
                                >
                                    ê²½ê³  ë°œì†¡
                                </button>
                                <button 
                                    className="btn-ignore"
                                    onClick={() => handleReviewLog(log.id, 'ignore', '')}
                                >
                                    ë¬´ì‹œ
                                </button>
                            </div>
                        </div>
                    ))}
                </div>
            )}
            
            {/* ìµœê·¼ ì²´í¬ */}
            <div className="recent-checks-panel">
                <h2>ìµœê·¼ ì¶œí‡´ê·¼</h2>
                
                <div className="checks-list">
                    {recentChecks.map((check, index) => (
                        <div key={index} className="check-item">
                            <span className="staff-name">{check.staff_name}</span>
                            <span className={`check-type ${check.check_type}`}>
                                {check.check_type === 'in' ? 'ğŸ¢ ì¶œê·¼' : 'ğŸ  í‡´ê·¼'}
                            </span>
                            <span className="check-time">
                                {format(new Date(check.check_time), 'HH:mm:ss')}
                            </span>
                        </div>
                    ))}
                </div>
            </div>
            
            {/* ë¯¸ì¶œê·¼ì */}
            {todayStats.missing.length > 0 && (
                <div className="missing-panel">
                    <h2>â° ë¯¸ì¶œê·¼ ({todayStats.missing.length}ëª…)</h2>
                    
                    <div className="missing-list">
                        {todayStats.missing.map(staff => (
                            <div key={staff.staff_id} className="missing-item">
                                <span className="name">{staff.staff_name}</span>
                                <span className="position">{staff.position}</span>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>
    );
}

export default AdminDashboard;
```

---

# 9. ë°°í¬ ë° ìš´ì˜

## 9.1 ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

```
â–¡ í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
  - SECRET_KEY: í† í° ìƒì„±ìš© ë¹„ë°€í‚¤
  - DATABASE_URL: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ë¬¸ìì—´
  - ALLOWED_ORIGINS: CORS í—ˆìš© ë„ë©”ì¸
  
â–¡ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
  - í…Œì´ë¸” ìƒì„± (ë§ˆì´ê·¸ë ˆì´ì…˜)
  - ì´ˆê¸° ë°ì´í„° ì…ë ¥ (ì§ì›, ì„¤ì •)
  - ë°±ì—… ì„¤ì •
  
â–¡ ë³´ì•ˆ ì„¤ì •
  - HTTPS ì ìš©
  - CORS ì„¤ì •
  - Rate Limiting
  - SQL Injection ë°©ì–´
  
â–¡ ìŠ¤ì¼€ì¤„ëŸ¬ ì„¤ì •
  - QR í† í° ìë™ ê°±ì‹ 
  - ë§Œë£Œ í† í° ì •ë¦¬
  - í†µê³„ ë°ì´í„° ê°±ì‹ 
  
â–¡ ë¡œê¹… ì„¤ì •
  - ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸
  - ì ‘ê·¼ ë¡œê·¸
  - ì˜¤ë¥˜ ë¡œê·¸
  - ë¡œê·¸ ë¡œí…Œì´ì…˜
  
â–¡ ëª¨ë‹ˆí„°ë§ ì„¤ì •
  - ì„œë²„ ìƒíƒœ ëª¨ë‹ˆí„°ë§
  - ì—ëŸ¬ ì•Œë¦¼
  - ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  
â–¡ ë°±ì—… ì„¤ì •
  - ë°ì´í„°ë² ì´ìŠ¤ ìë™ ë°±ì—…
  - ë³µêµ¬ í…ŒìŠ¤íŠ¸
```

---

## 9.2 ìš´ì˜ ê°€ì´ë“œ

### ì¼ì¼ ì²´í¬ì‚¬í•­

```
ì•„ì¹¨ (09:00)
â–¡ QR ì½”ë“œ ì •ìƒ í‘œì‹œ í™•ì¸
â–¡ ì¶œê·¼ ì²´í¬ ì •ìƒ ì‘ë™ í™•ì¸
â–¡ ì˜ì‹¬ íŒ¨í„´ ë¡œê·¸ í™•ì¸

ì €ë… (19:00)
â–¡ í‡´ê·¼ ì²´í¬ ëˆ„ë½ì í™•ì¸
â–¡ ì˜¤ëŠ˜ í†µê³„ í™•ì¸
â–¡ ì‹œìŠ¤í…œ ë¡œê·¸ í™•ì¸
```

### ì£¼ê°„ ì²´í¬ì‚¬í•­

```
â–¡ ë””ë°”ì´ìŠ¤ ì‚¬ìš© í˜„í™© í™•ì¸
â–¡ ì˜ì‹¬ íŒ¨í„´ ëˆ„ì  í†µê³„ í™•ì¸
â–¡ ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… í™•ì¸
â–¡ ì„œë²„ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥  í™•ì¸
```

### ì›”ê°„ ì²´í¬ì‚¬í•­

```
â–¡ ì›”ê°„ í†µê³„ ìƒì„±
â–¡ ê°œì¸ë³„ ì¶œí‡´ê·¼ ë¦¬í¬íŠ¸ ìƒì„±
â–¡ ì‹œìŠ¤í…œ ì„±ëŠ¥ ë¶„ì„
â–¡ ë¡œê·¸ íŒŒì¼ ì •ë¦¬
â–¡ ë³´ì•ˆ ì—…ë°ì´íŠ¸ í™•ì¸
```

---

## 9.3 ë¬¸ì œ í•´ê²° ê°€ì´ë“œ

### QR ì½”ë“œê°€ ì‘ë™í•˜ì§€ ì•Šì„ ë•Œ

```
1. ë¸Œë¼ìš°ì € ì½˜ì†” í™•ì¸
   - F12 â†’ Console íƒ­
   - ì˜¤ë¥˜ ë©”ì‹œì§€ í™•ì¸

2. í† í° ìƒíƒœ í™•ì¸
   GET /api/qr/current
   - ì •ìƒ ì‘ë‹µ í™•ì¸
   - expires_at ì‹œê°„ í™•ì¸

3. ìŠ¤ì¼€ì¤„ëŸ¬ ìƒíƒœ í™•ì¸
   - ë¡œê·¸ì—ì„œ "QR í† í° ê°±ì‹  ì™„ë£Œ" ë©”ì‹œì§€ í™•ì¸
   - 5ë¶„ë§ˆë‹¤ ê°±ì‹ ë˜ëŠ”ì§€ í™•ì¸

4. ë°ì´í„°ë² ì´ìŠ¤ í™•ì¸
   SELECT * FROM qr_tokens 
   WHERE is_active = true 
   ORDER BY created_at DESC 
   LIMIT 1;
```

### ì¶œê·¼ ì²´í¬ê°€ ì‹¤íŒ¨í•  ë•Œ

```
1. ì˜¤ë¥˜ ë©”ì‹œì§€ í™•ì¸
   - "QR ì½”ë“œê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤" â†’ QR ë‹¤ì‹œ ìŠ¤ìº”
   - "ì´ë¯¸ ì¶œê·¼ ì²´í¬í•˜ì…¨ìŠµë‹ˆë‹¤" â†’ ì¤‘ë³µ ì²´í¬
   - "ì°¨ë‹¨ëœ ë””ë°”ì´ìŠ¤ì…ë‹ˆë‹¤" â†’ ë””ë°”ì´ìŠ¤ ì°¨ë‹¨ í•´ì œ í•„ìš”

2. í† í° ê²€ì¦ ë¡œê·¸ í™•ì¸
   - ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸ì—ì„œ ê²€ì¦ ì‹¤íŒ¨ ì›ì¸ í™•ì¸

3. ë””ë°”ì´ìŠ¤ ìƒíƒœ í™•ì¸
   SELECT * FROM device_info 
   WHERE fingerprint = '...';
   
   - is_blocked í™•ì¸

4. ì‹œê°„ëŒ€ ì„¤ì • í™•ì¸
   SELECT * FROM settings 
   WHERE key LIKE '%time%';
```

### ì˜ì‹¬ íŒ¨í„´ì´ ê³¼ë‹¤ ë°œìƒí•  ë•Œ

```
1. ì„¤ì • ì¡°ì •
   - consecutive_check_threshold ì¦ê°€ (3 â†’ 5)
   - consecutive_check_minutes ì¦ê°€ (1 â†’ 3)

2. ì •ìƒ íŒ¨í„´ í™•ì¸
   - ì¶œê·¼ ì‹œê°„ëŒ€ì— ì—¬ëŸ¬ ëª…ì´ í•¨ê»˜ ë„ì°©í•˜ëŠ” ê²½ìš° ì •ìƒ
   - ì ‘ìˆ˜ íƒœë¸”ë¦¿ì„ ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì •ìƒ

3. ë””ë°”ì´ìŠ¤ ë³„ëª… ì„¤ì •
   - ì•Œê¸° ì‰¬ìš´ ë³„ëª…ìœ¼ë¡œ ë³€ê²½
   - "ì ‘ìˆ˜ íƒœë¸”ë¦¿", "íœ´ê²Œì‹¤ í°" ë“±
```

---

# 10. í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

## 10.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```python
# test_qr_token.py

import pytest
from datetime import datetime, timedelta
from qr_token import QRTokenManager

def test_generate_token():
    """í† í° ìƒì„± í…ŒìŠ¤íŠ¸"""
    manager = QRTokenManager(
        secret_key="test_key",
        refresh_interval=300
    )
    
    token = manager.generate_token()
    
    assert token['token'] is not None
    assert len(token['token']) == 16
    assert token['expires_at'] > datetime.now()
    assert 'url' in token


def test_validate_token_expired():
    """ë§Œë£Œëœ í† í° ê²€ì¦ í…ŒìŠ¤íŠ¸"""
    manager = QRTokenManager(
        secret_key="test_key",
        refresh_interval=1  # 1ì´ˆ
    )
    
    token = manager.generate_token()
    
    # 2ì´ˆ ëŒ€ê¸° (í† í° ë§Œë£Œ)
    import time
    time.sleep(2)
    
    result = manager.validate_token(token['token'])
    
    assert result['valid'] == False
    assert result['reason'] == 'TOKEN_EXPIRED'


# test_device_fingerprint.py

def test_device_fingerprint_consistency():
    """ê°™ì€ ë””ë°”ì´ìŠ¤ëŠ” ê°™ì€ í•‘ê±°í”„ë¦°íŠ¸ ìƒì„±"""
    device_info = {
        'userAgent': 'Mozilla/5.0...',
        'platform': 'iPhone',
        'screenWidth': 390,
        'screenHeight': 844,
        # ...
    }
    
    fp1 = DeviceFingerprint.generate(device_info)
    fp2 = DeviceFingerprint.generate(device_info)
    
    assert fp1 == fp2


def test_device_fingerprint_different():
    """ë‹¤ë¥¸ ë””ë°”ì´ìŠ¤ëŠ” ë‹¤ë¥¸ í•‘ê±°í”„ë¦°íŠ¸ ìƒì„±"""
    device_info1 = {
        'userAgent': 'Mozilla/5.0...',
        'platform': 'iPhone',
        # ...
    }
    
    device_info2 = {
        'userAgent': 'Mozilla/5.0...',
        'platform': 'Android',
        # ...
    }
    
    fp1 = DeviceFingerprint.generate(device_info1)
    fp2 = DeviceFingerprint.generate(device_info2)
    
    assert fp1 != fp2


# test_attendance_validator.py

def test_duplicate_checkin_detection():
    """ì¤‘ë³µ ì¶œê·¼ ì²´í¬ ê°ì§€"""
    validator = AttendanceValidator(db, token_manager, device_manager)
    
    # ì²« ë²ˆì§¸ ì¶œê·¼ ì²´í¬ (ì„±ê³µ)
    valid1, msg1 = validator.validate_checkin(staff_id=1, token='valid_token', device_info={})
    assert valid1 == True
    
    # ë‘ ë²ˆì§¸ ì¶œê·¼ ì²´í¬ (ì‹¤íŒ¨ - ì¤‘ë³µ)
    valid2, msg2 = validator.validate_checkin(staff_id=1, token='valid_token', device_info={})
    assert valid2 == False
    assert 'ì´ë¯¸ ì¶œê·¼ ì²´í¬' in msg2


def test_time_validation():
    """ì‹œê°„ëŒ€ ê²€ì¦"""
    # ì„¤ì •: ì¶œê·¼ ì²´í¬ ê°€ëŠ¥ ì‹œê°„ 06:00~12:00
    
    validator = AttendanceValidator(db, token_manager, device_manager)
    
    # ì˜¤ì „ 9ì‹œ (ì„±ê³µ)
    with freeze_time("2025-01-20 09:00:00"):
        valid, msg = validator._validate_checkin_time()
        assert valid == True
    
    # ì˜¤í›„ 3ì‹œ (ì‹¤íŒ¨)
    with freeze_time("2025-01-20 15:00:00"):
        valid, msg = validator._validate_checkin_time()
        assert valid == False
```

---

## 10.2 í†µí•© í…ŒìŠ¤íŠ¸

```python
# test_attendance_flow.py

import pytest
from flask import Flask
from datetime import datetime

@pytest.fixture
def client():
    app = create_app('testing')
    with app.test_client() as client:
        yield client


def test_full_checkin_flow(client):
    """ì „ì²´ ì¶œê·¼ ì²´í¬ íë¦„ í…ŒìŠ¤íŠ¸"""
    
    # 1. QR í† í° ê°€ì ¸ì˜¤ê¸°
    response = client.get('/api/qr/current')
    assert response.status_code == 200
    
    data = response.get_json()
    token = data['token']
    
    # 2. ì¶œê·¼ ì²´í¬
    checkin_data = {
        'staff_id': 1,
        'token': token,
        'device_info': {
            'fingerprint': 'test_fingerprint_123',
            'userAgent': 'Test Agent',
            'platform': 'Test Platform'
        }
    }
    
    response = client.post('/api/attendance/check-in', json=checkin_data)
    assert response.status_code == 200
    
    data = response.get_json()
    assert data['success'] == True
    assert 'record_id' in data['data']
    
    # 3. ê¸°ë¡ í™•ì¸
    response = client.get(f"/api/attendance/records?staff_id=1")
    assert response.status_code == 200
    
    data = response.get_json()
    assert len(data['data']['records']) > 0
    assert data['data']['records'][0]['check_type'] == 'in'


def test_consecutive_check_detection(client):
    """ì—°ì† ì²´í¬ ê°ì§€ í…ŒìŠ¤íŠ¸"""
    
    # QR í† í°
    response = client.get('/api/qr/current')
    token = response.get_json()['token']
    
    # ê°™ì€ ë””ë°”ì´ìŠ¤ë¡œ 3ëª… ì—°ì† ì²´í¬
    device_fp = 'test_device_consecutive'
    
    for staff_id in [1, 2, 3]:
        response = client.post('/api/attendance/check-in', json={
            'staff_id': staff_id,
            'token': token,
            'device_info': {
                'fingerprint': device_fp,
                'userAgent': 'Test'
            }
        })
        assert response.status_code == 200
    
    # ì˜ì‹¬ ë¡œê·¸ í™•ì¸
    response = client.get('/api/suspicious/logs?reviewed=false')
    data = response.get_json()
    
    logs = data['data']['logs']
    consecutive_logs = [
        log for log in logs 
        if log['pattern_type'] == 'consecutive_checks'
    ]
    
    assert len(consecutive_logs) > 0
```

---

## 10.3 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

```python
# test_performance.py

import pytest
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

def test_concurrent_checkins(client):
    """ë™ì‹œ ì¶œê·¼ ì²´í¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    # QR í† í°
    response = client.get('/api/qr/current')
    token = response.get_json()['token']
    
    # 20ëª… ë™ì‹œ ì¶œê·¼ ì²´í¬
    def check_in(staff_id):
        start_time = time.time()
        
        response = client.post('/api/attendance/check-in', json={
            'staff_id': staff_id,
            'token': token,
            'device_info': {
                'fingerprint': f'device_{staff_id}',
                'userAgent': 'Test'
            }
        })
        
        elapsed = time.time() - start_time
        return response.status_code, elapsed
    
    with ThreadPoolExecutor(max_workers=20) as executor:
        futures = [executor.submit(check_in, i) for i in range(1, 21)]
        
        results = []
        for future in as_completed(futures):
            status, elapsed = future.result()
            results.append((status, elapsed))
    
    # ê²€ì¦
    success_count = sum(1 for status, _ in results if status == 200)
    avg_time = sum(elapsed for _, elapsed in results) / len(results)
    max_time = max(elapsed for _, elapsed in results)
    
    print(f"ì„±ê³µ: {success_count}/20")
    print(f"í‰ê·  ì‘ë‹µ ì‹œê°„: {avg_time:.3f}ì´ˆ")
    print(f"ìµœëŒ€ ì‘ë‹µ ì‹œê°„: {max_time:.3f}ì´ˆ")
    
    assert success_count == 20
    assert avg_time < 1.0  # í‰ê·  1ì´ˆ ì´ë‚´
    assert max_time < 2.0  # ìµœëŒ€ 2ì´ˆ ì´ë‚´


def test_database_query_performance():
    """ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    # 1ë§Œ ê±´ ë°ì´í„° ìƒì„±
    create_test_data(count=10000)
    
    # ì›”ê°„ í†µê³„ ì¡°íšŒ ì„±ëŠ¥
    start_time = time.time()
    stats = get_monthly_stats(year=2025, month=1)
    elapsed = time.time() - start_time
    
    print(f"ì›”ê°„ í†µê³„ ì¡°íšŒ ì‹œê°„: {elapsed:.3f}ì´ˆ")
    assert elapsed < 1.0  # 1ì´ˆ ì´ë‚´
```

---

# ë§ˆë¬´ë¦¬

ì´ ë¬¸ì„œëŠ” ì—°ì„¸ë°”ë¡œì¹˜ê³¼ ê·¼íƒœê´€ë¦¬ ì‹œìŠ¤í…œ ê°œë°œì„ ìœ„í•œ ì™„ì „í•œ ê°€ì´ë“œì…ë‹ˆë‹¤.

## ê°œë°œ ìš°ì„ ìˆœìœ„

```
Phase 1: ê¸°ë³¸ ê¸°ëŠ¥ (1-2ì£¼)
â”œâ”€ QR í† í° ì‹œìŠ¤í…œ
â”œâ”€ ì¶œí‡´ê·¼ ì²´í¬ API
â”œâ”€ ë””ë°”ì´ìŠ¤ ì¶”ì 
â””â”€ ê¸°ë³¸ ê´€ë¦¬ì í™”ë©´

Phase 2: ë³´ì•ˆ ê°•í™” (1ì£¼)
â”œâ”€ ì´ìƒ íŒ¨í„´ ê°ì§€
â”œâ”€ ì˜ì‹¬ ë¡œê·¸ ì‹œìŠ¤í…œ
â””â”€ ê´€ë¦¬ì ì•Œë¦¼

Phase 3: í†µê³„ ë° ë¦¬í¬íŠ¸ (1ì£¼)
â”œâ”€ ì¼/ì›” í†µê³„
â”œâ”€ ê°œì¸ë³„ ë¶„ì„
â””â”€ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ

Phase 4: ì™„ì„±ë„ í–¥ìƒ (1ì£¼)
â”œâ”€ UI/UX ê°œì„ 
â”œâ”€ ì„±ëŠ¥ ìµœì í™”
â””â”€ í…ŒìŠ¤íŠ¸ ë° ë²„ê·¸ ìˆ˜ì •
```

## ì°¸ê³  ìë£Œ

- Flask ê³µì‹ ë¬¸ì„œ: https://flask.palletsprojects.com/
- SQLAlchemy ë¬¸ì„œ: https://docs.sqlalchemy.org/
- APScheduler ë¬¸ì„œ: https://apscheduler.readthedocs.io/
- React ê³µì‹ ë¬¸ì„œ: https://react.dev/

---

**ë¬¸ì„œ ë²„ì „**: 1.0  
**ìµœì¢… ìˆ˜ì •**: 2025ë…„ 10ì›” 22ì¼  
**ì‘ì„±ì**: ê°œë°œíŒ€

ê°œë°œ ì¤‘ ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ì—°ë½ì£¼ì„¸ìš”!
